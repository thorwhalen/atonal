

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>atonal.base &mdash; atonal 0.0.5 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=282f96c0"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/toggleprompt.js?v=d7ede5d2"></script>
      <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            atonal
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/atonal/base.html">atonal.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/atonal/tests/test_chordspace.html">atonal.tests.test_chordspace</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">atonal</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">atonal.base</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for atonal.base</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">base.py</span>

<span class="sd">A comprehensive module for pitch-class set theory and chord voicing analysis.</span>

<span class="sd">This module provides two main functionalities:</span>

<span class="sd">1. **Forte-Style Pitch-Class Set Theory** (Section 0)</span>
<span class="sd">   - Complete enumeration and analysis of all 4,096 subsets of the 12 pitch classes</span>
<span class="sd">   - Implementation of Allen Forte&#39;s analytical framework from &quot;The Structure of</span>
<span class="sd">     Atonal Music&quot; (1973)</span>
<span class="sd">   - Computation of prime forms, interval vectors, Z-relations, invariance properties,</span>
<span class="sd">     and more</span>
<span class="sd">   - See `tonal/misc/forte_sets.md` for comprehensive field documentation</span>

<span class="sd">2. **Chord Voicing Generation and Graph Construction** (Sections 1-4)</span>
<span class="sd">   - Enumeration of chord voicings in bounded pitch ranges</span>
<span class="sd">   - Graph construction based on voice-leading, shared pitch classes, and subset</span>
<span class="sd">     relations</span>
<span class="sd">   - Flexible link types for different analytical purposes</span>

<span class="sd">Conventions</span>
<span class="sd">-----------</span>
<span class="sd">- Pitch classes are 0..11 (0 = C, 1 = C#, ..., 11 = B)</span>
<span class="sd">- Pitches (not just pitch classes) are integers too: 60 = C4, etc., but here we</span>
<span class="sd">  mostly use small integers as semitone offsets from a root</span>
<span class="sd">- A &quot;pc-set&quot; is a frozenset of pitch classes</span>
<span class="sd">- A &quot;voicing&quot; is a tuple of *pitches* (ordered), e.g. (0, 4, 7), (0, 7, 12)</span>
<span class="sd">- A &quot;chord node&quot; in the graph is usually an int-indexed entry referring to a</span>
<span class="sd">  voicing or a pc-set</span>

<span class="sd">Differences from pctheory</span>
<span class="sd">--------------------------</span>
<span class="sd">This implementation differs from the `pctheory` library in several ways:</span>

<span class="sd">1. **Prime form algorithm**: Uses lexicographic normal order vs pctheory&#39;s</span>
<span class="sd">   &quot;weight from right&quot; approach. Results match for 99%+ of sets but may differ</span>
<span class="sd">   for edge cases. Use `validate_prime_forms()` to check.</span>

<span class="sd">2. **Scope**: Focuses on mod-12 chromatic sets. pctheory supports arbitrary</span>
<span class="sd">   moduli (e.g., mod-24 for quarter-tones).</span>

<span class="sd">3. **Data structures**: Returns frozensets/tuples vs pctheory&#39;s PitchClass objects.</span>

<span class="sd">4. **Output format**: Builds pandas DataFrames for graph analysis vs pctheory&#39;s</span>
<span class="sd">   object-oriented SetClass API.</span>

<span class="sd">5. **Additional features**: This module includes:</span>
<span class="sd">   - `multiply()` for M_n transformations</span>
<span class="sd">   - `contains_abstract_subset()` for abstract inclusion checking</span>
<span class="sd">   - `get_k_complex_size()` for K complex calculations (non-reciprocal version)</span>
<span class="sd">   - Comprehensive DataFrame builders for network analysis</span>

<span class="sd">6. **Missing features**: Compared to pctheory, this module does not include:</span>
<span class="sd">   - Carter and Morris naming systems</span>
<span class="sd">   - Ordered operations (retrograde, rotate) for pc-segments</span>
<span class="sd">   - Microtonal support (mod 24+)</span>
<span class="sd">   - Full invariance vectors (8-element format)</span>

<span class="sd">Validation</span>
<span class="sd">----------</span>
<span class="sd">Run validation tests with:</span>
<span class="sd">    &gt;&gt;&gt; from atonal.base import validate_prime_forms</span>
<span class="sd">    &gt;&gt;&gt; validate_prime_forms()  # doctest: +SKIP</span>
<span class="sd">    ✓ All prime forms match Forte canonical forms!</span>

<span class="sd">References</span>
<span class="sd">----------</span>
<span class="sd">Forte, Allen. &quot;The Structure of Atonal Music.&quot; Yale University Press, 1973.</span>
<span class="sd">https://www.amazon.com/Structure-Atonal-Music-Allen-Forte/dp/0300021208</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">lru_cache</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">combinations</span><span class="p">,</span> <span class="n">product</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">Iterator</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
    <span class="n">Set</span><span class="p">,</span>
    <span class="n">FrozenSet</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Hashable</span><span class="p">,</span>
<span class="p">)</span>


<span class="c1"># ---------------------------------------------------------------------------</span>
<span class="c1"># 0. PC-SET THEORY (FORTE-STYLE UTILITIES)</span>
<span class="c1"># ---------------------------------------------------------------------------</span>


<span class="nd">@lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_int_to_pcset</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert a 12-bit bitmap (0..4095) to a sorted pc tuple.</span>

<span class="sd">    &gt;&gt;&gt; _int_to_pcset(0)</span>
<span class="sd">    ()</span>
<span class="sd">    &gt;&gt;&gt; _int_to_pcset(145)  # 0b10010001 -&gt; {0,4,7}</span>
<span class="sd">    (0, 4, 7)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">4096</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;pc-set bitmap out of range [0, 4095]: </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>


<div class="viewcode-block" id="int_to_pcset">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.int_to_pcset">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">int_to_pcset</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Public alias for bitmap -&gt; tuple.</span>

<span class="sd">    &gt;&gt;&gt; int_to_pcset(145)</span>
<span class="sd">    (0, 4, 7)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_int_to_pcset</span><span class="p">(</span><span class="n">n</span><span class="p">)</span></div>



<div class="viewcode-block" id="pcset_to_int">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.pcset_to_int">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">pcset_to_int</span><span class="p">(</span><span class="n">pcs</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert a pc iterable to a 12-bit bitmap int.</span>

<span class="sd">    &gt;&gt;&gt; pcset_to_int((0, 4, 7))</span>
<span class="sd">    145</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">pcs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="mi">12</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Pitch classes must be in [0, 11], got </span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">p</span>
    <span class="k">return</span> <span class="n">n</span></div>



<div class="viewcode-block" id="transpose">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.transpose">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">transpose</span><span class="p">(</span><span class="n">pc_set</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">interval</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrozenSet</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Transpose a pc-set by `interval` modulo 12.</span>

<span class="sd">    &gt;&gt;&gt; transpose((0, 4, 7), 1) == frozenset({1, 5, 8})</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">frozenset</span><span class="p">(((</span><span class="n">p</span> <span class="o">+</span> <span class="n">interval</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">pc_set</span><span class="p">))</span></div>



<div class="viewcode-block" id="invert">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.invert">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">invert</span><span class="p">(</span><span class="n">pc_set</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">FrozenSet</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Invert a pc-set about 0 (map p -&gt; -p mod 12).</span>

<span class="sd">    &gt;&gt;&gt; invert((0, 4, 7)) == frozenset({0, 5, 8})</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">frozenset</span><span class="p">(((</span><span class="o">-</span><span class="n">p</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">pc_set</span><span class="p">))</span></div>



<div class="viewcode-block" id="multiply">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.multiply">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">multiply</span><span class="p">(</span><span class="n">pc_set</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrozenSet</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Multiply all pitch classes by n (mod 12).</span>

<span class="sd">    The M_n transformation multiplies each pitch class by n modulo 12.</span>
<span class="sd">    This is useful for extended transformations like T5M7 (transpose 5, multiply by 7).</span>

<span class="sd">    &gt;&gt;&gt; multiply((0, 4, 7), 5) == frozenset({0, 8, 11})</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; multiply((0, 1, 2), 5) == frozenset({0, 5, 10})</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">frozenset</span><span class="p">((</span><span class="n">p</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">pc_set</span><span class="p">))</span></div>



<div class="viewcode-block" id="best_normal_order">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.best_normal_order">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">best_normal_order</span><span class="p">(</span><span class="n">pc_set</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the best normal order (Forte&#39;s packed rotation).</span>

<span class="sd">    This is the *pre-prime* ordering: a circular permutation of the pcs in</span>
<span class="sd">    ascending registral order, chosen to be most compact.</span>

<span class="sd">    Field utility (dataset): “Best Normal Order” provides the canonical</span>
<span class="sd">    *template ordering* before transposition-to-0, useful for identifying sets</span>
<span class="sd">    encountered in music.</span>

<span class="sd">    &gt;&gt;&gt; best_normal_order((0, 4, 7))</span>
<span class="sd">    (0, 4, 7)</span>
<span class="sd">    &gt;&gt;&gt; best_normal_order((11, 0, 3, 8))  # one valid compact ordering</span>
<span class="sd">    (8, 11, 0, 3)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">pcs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">pc_set</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">pcs</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pcs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">pcs</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span>

    <span class="n">candidates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pcs</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">rotated</span> <span class="o">=</span> <span class="n">pcs</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span> <span class="o">+</span> <span class="p">[</span><span class="n">p</span> <span class="o">+</span> <span class="mi">12</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pcs</span><span class="p">[:</span><span class="n">i</span><span class="p">]]</span>
        <span class="n">span</span> <span class="o">=</span> <span class="n">rotated</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">rotated</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># requirement 2: tie-break by smallest successive distance-from-first</span>
        <span class="n">dist_from_first</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">rotated</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">rotated</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="n">candidates</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">span</span><span class="p">,</span> <span class="n">dist_from_first</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p</span> <span class="o">%</span> <span class="mi">12</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">rotated</span><span class="p">)))</span>

    <span class="n">candidates</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">candidates</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_transpose_to_zero</span><span class="p">(</span><span class="n">order</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">order</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">()</span>
    <span class="n">first</span> <span class="o">=</span> <span class="n">order</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(((</span><span class="n">p</span> <span class="o">-</span> <span class="n">first</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">order</span><span class="p">)</span>


<div class="viewcode-block" id="prime_form">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.prime_form">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">prime_form</span><span class="p">(</span><span class="n">pc_set</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the prime form under T/I equivalence.</span>

<span class="sd">    Uses best normal order for the set and its inversion, transposes each to 0,</span>
<span class="sd">    and returns the lexicographically smaller.</span>

<span class="sd">    &gt;&gt;&gt; prime_form((0, 4, 7))</span>
<span class="sd">    (0, 3, 7)</span>
<span class="sd">    &gt;&gt;&gt; prime_form(())</span>
<span class="sd">    ()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pcs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">pc_set</span><span class="p">)))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">pcs</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">()</span>

    <span class="n">no</span> <span class="o">=</span> <span class="n">best_normal_order</span><span class="p">(</span><span class="n">pcs</span><span class="p">)</span>
    <span class="n">inv_no</span> <span class="o">=</span> <span class="n">best_normal_order</span><span class="p">(</span><span class="n">invert</span><span class="p">(</span><span class="n">pcs</span><span class="p">))</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">_transpose_to_zero</span><span class="p">(</span><span class="n">no</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">_transpose_to_zero</span><span class="p">(</span><span class="n">inv_no</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span></div>



<div class="viewcode-block" id="interval_vector">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.interval_vector">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">interval_vector</span><span class="p">(</span><span class="n">pc_set</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the interval vector (ic1..ic6) for a pc-set.</span>

<span class="sd">    &gt;&gt;&gt; interval_vector((0, 4, 7))</span>
<span class="sd">    (0, 0, 1, 1, 1, 0)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pcs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">pc_set</span><span class="p">))</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pcs</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">6</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="p">(</span><span class="n">pcs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">pcs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">%</span> <span class="mi">12</span>
            <span class="n">ic</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="mi">12</span> <span class="o">-</span> <span class="n">diff</span><span class="p">)</span>
            <span class="n">v</span><span class="p">[</span><span class="n">ic</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>  <span class="c1"># type: ignore[return-value]</span></div>



<div class="viewcode-block" id="is_transpositionally_symmetric">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.is_transpositionally_symmetric">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">is_transpositionally_symmetric</span><span class="p">(</span><span class="n">pc_set</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;True if the set is invariant under some non-zero transposition.</span>

<span class="sd">    &gt;&gt;&gt; is_transpositionally_symmetric((0, 3, 6, 9))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_transpositionally_symmetric((0, 4, 7))</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">pc_set</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">transpose</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span></div>



<div class="viewcode-block" id="distinct_transpositions">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.distinct_transpositions">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">distinct_transpositions</span><span class="p">(</span><span class="n">pc_set</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Number of distinct transpositions n(T) in the T-orbit.</span>

<span class="sd">    Theoretical utility (Forte Part 1 §1.11): symmetric sets yield fewer than 12</span>
<span class="sd">    distinct transpositions.</span>

<span class="sd">    &gt;&gt;&gt; distinct_transpositions((0, 4, 7))</span>
<span class="sd">    12</span>
<span class="sd">    &gt;&gt;&gt; distinct_transpositions((0, 3, 6, 9))</span>
<span class="sd">    3</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">pc_set</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">({</span><span class="n">transpose</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">)})</span></div>



<div class="viewcode-block" id="distinct_inversions">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.distinct_inversions">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">distinct_inversions</span><span class="p">(</span><span class="n">pc_set</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Number of distinct inversions n(I) in the IT-orbit.</span>

<span class="sd">    Theoretical utility (Forte Part 1 §1.12): sets that are replicas of their</span>
<span class="sd">    own inversion (up to transposition) reduce the total number of distinct</span>
<span class="sd">    forms.</span>

<span class="sd">    &gt;&gt;&gt; distinct_inversions((0, 4, 7))</span>
<span class="sd">    12</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">pc_set</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">({</span><span class="nb">frozenset</span><span class="p">(((</span><span class="n">n</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">)})</span></div>



<div class="viewcode-block" id="max_invariance_degrees">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.max_invariance_degrees">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">max_invariance_degrees</span><span class="p">(</span><span class="n">pc_set</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Maximum invariants under transposition and inversion.</span>

<span class="sd">    Theoretical utility (Forte Part 1 §§1.11–1.12): quantifies how many pitch</span>
<span class="sd">    classes remain fixed (invariant) under the *best* non-trivial T_n and I T_n.</span>

<span class="sd">    Returns a dict with keys:</span>
<span class="sd">      - max_T_invariance, max_T_invariance_n</span>
<span class="sd">      - max_I_invariance, max_I_invariance_n</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">pc_set</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;max_T_invariance&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;max_T_invariance_n&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;max_I_invariance&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;max_I_invariance_n&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="n">best_t</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">best_t_n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">):</span>
        <span class="n">inv</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span> <span class="o">&amp;</span> <span class="n">transpose</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">inv</span> <span class="o">&gt;</span> <span class="n">best_t</span><span class="p">:</span>
            <span class="n">best_t</span> <span class="o">=</span> <span class="n">inv</span>
            <span class="n">best_t_n</span> <span class="o">=</span> <span class="n">n</span>

    <span class="n">best_i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">best_i_n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">):</span>
        <span class="n">it</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(((</span><span class="n">n</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">s</span><span class="p">)</span>
        <span class="n">inv</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span> <span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inv</span> <span class="o">&gt;</span> <span class="n">best_i</span><span class="p">:</span>
            <span class="n">best_i</span> <span class="o">=</span> <span class="n">inv</span>
            <span class="n">best_i_n</span> <span class="o">=</span> <span class="n">n</span>

    <span class="k">return</span> <span class="p">{</span>
        <span class="s2">&quot;max_T_invariance&quot;</span><span class="p">:</span> <span class="n">best_t</span><span class="p">,</span>
        <span class="s2">&quot;max_T_invariance_n&quot;</span><span class="p">:</span> <span class="n">best_t_n</span><span class="p">,</span>
        <span class="s2">&quot;max_I_invariance&quot;</span><span class="p">:</span> <span class="n">best_i</span><span class="p">,</span>
        <span class="s2">&quot;max_I_invariance_n&quot;</span><span class="p">:</span> <span class="n">best_i_n</span><span class="p">,</span>
    <span class="p">}</span></div>



<div class="viewcode-block" id="combinatorial_property_hexachord">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.combinatorial_property_hexachord">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">combinatorial_property_hexachord</span><span class="p">(</span><span class="n">pc_set</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Combinatorial property label for hexachords (cardinality 6).</span>

<span class="sd">    Theoretical utility (Forte Part 1 §1.14): flags hexachords that can form a</span>
<span class="sd">    12-tone aggregate with one of their own T_n or I T_n transforms.</span>

<span class="sd">    Returns:</span>
<span class="sd">      - &#39;a&#39; (all-combinatorial): both T and I combinatorial</span>
<span class="sd">      - &#39;p&#39; (prime combinatorial): T combinatorial only</span>
<span class="sd">      - &#39;i&#39; (inversion combinatorial): I combinatorial only</span>
<span class="sd">      - None: not combinatorial or not a hexachord</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">pc_set</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">6</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">t_ok</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span> <span class="o">&amp;</span> <span class="n">transpose</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>
    <span class="n">i_ok</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span> <span class="o">&amp;</span> <span class="nb">frozenset</span><span class="p">(((</span><span class="n">n</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">s</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">t_ok</span> <span class="ow">and</span> <span class="n">i_ok</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;a&quot;</span>
    <span class="k">if</span> <span class="n">t_ok</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;p&quot;</span>
    <span class="k">if</span> <span class="n">i_ok</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;i&quot;</span>
    <span class="k">return</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="kh_complex_size">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.kh_complex_size">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">kh_complex_size</span><span class="p">(</span><span class="n">nexus</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">universe_mask</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4095</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute Kh-complex size for a nexus set (bitmap int).</span>

<span class="sd">    Uses the operational definition from Forte Part 2 (§2.2–2.3) as summarized</span>
<span class="sd">    in the notebook request:</span>

<span class="sd">    A set S is in Kh(T) iff:</span>
<span class="sd">      (S ⊆ T or T ⊆ S) AND (S ⊆ T&#39; or T&#39; ⊆ S)</span>
<span class="sd">    where T&#39; is the complement of T.</span>

<span class="sd">    Returns the count of S in the 12-tone universe satisfying the condition.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">nexus</span> <span class="o">&lt;</span> <span class="mi">4096</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nexus must be in [0, 4095], got </span><span class="si">{</span><span class="n">nexus</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">comp</span> <span class="o">=</span> <span class="n">universe_mask</span> <span class="o">^</span> <span class="n">nexus</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">universe_mask</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">rel_t</span> <span class="o">=</span> <span class="p">((</span><span class="n">s</span> <span class="o">&amp;</span> <span class="n">nexus</span><span class="p">)</span> <span class="o">==</span> <span class="n">s</span><span class="p">)</span> <span class="ow">or</span> <span class="p">((</span><span class="n">s</span> <span class="o">&amp;</span> <span class="n">nexus</span><span class="p">)</span> <span class="o">==</span> <span class="n">nexus</span><span class="p">)</span>
        <span class="n">rel_c</span> <span class="o">=</span> <span class="p">((</span><span class="n">s</span> <span class="o">&amp;</span> <span class="n">comp</span><span class="p">)</span> <span class="o">==</span> <span class="n">s</span><span class="p">)</span> <span class="ow">or</span> <span class="p">((</span><span class="n">s</span> <span class="o">&amp;</span> <span class="n">comp</span><span class="p">)</span> <span class="o">==</span> <span class="n">comp</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rel_t</span> <span class="ow">and</span> <span class="n">rel_c</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">count</span></div>



<span class="c1"># --- Forte-class naming ------------------------------------------------------</span>

<span class="c1"># Note: This is intentionally just a lookup table (prime_form -&gt; Forte label).</span>
<span class="c1"># It can be extended later or replaced by a data file.</span>
<span class="n">FORTE_CLASSES</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span> <span class="s2">&quot;3-1&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span> <span class="s2">&quot;3-2&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span> <span class="s2">&quot;3-3&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span> <span class="s2">&quot;3-4&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span> <span class="s2">&quot;3-5&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span> <span class="s2">&quot;3-6&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span> <span class="s2">&quot;3-7&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span> <span class="s2">&quot;3-8&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span> <span class="s2">&quot;3-9&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span> <span class="s2">&quot;3-10&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span> <span class="s2">&quot;3-11&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span> <span class="s2">&quot;3-12&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span> <span class="s2">&quot;4-1&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span> <span class="s2">&quot;4-2&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span> <span class="s2">&quot;4-3&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span> <span class="s2">&quot;4-4&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span> <span class="s2">&quot;4-5&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span> <span class="s2">&quot;4-6&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span> <span class="s2">&quot;4-7&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span> <span class="s2">&quot;4-8&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span> <span class="s2">&quot;4-9&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span> <span class="s2">&quot;4-10&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span> <span class="s2">&quot;4-11&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span> <span class="s2">&quot;4-12&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span> <span class="s2">&quot;4-13&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span> <span class="s2">&quot;4-14&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span> <span class="s2">&quot;4-15&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span> <span class="s2">&quot;4-16&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span> <span class="s2">&quot;4-17&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span> <span class="s2">&quot;4-18&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span> <span class="s2">&quot;4-19&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span> <span class="s2">&quot;4-20&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span> <span class="s2">&quot;4-21&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span> <span class="s2">&quot;4-22&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span> <span class="s2">&quot;4-23&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span> <span class="s2">&quot;4-24&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span> <span class="s2">&quot;4-25&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span> <span class="s2">&quot;4-26&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span> <span class="s2">&quot;4-27&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">):</span> <span class="s2">&quot;4-28&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span> <span class="s2">&quot;4-Z29&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span> <span class="s2">&quot;5-1&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span> <span class="s2">&quot;5-2&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span> <span class="s2">&quot;5-3&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span> <span class="s2">&quot;5-4&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span> <span class="s2">&quot;5-5&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span> <span class="s2">&quot;5-6&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span> <span class="s2">&quot;5-7&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span> <span class="s2">&quot;5-8&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span> <span class="s2">&quot;5-9&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span> <span class="s2">&quot;5-10&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span> <span class="s2">&quot;5-11&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span> <span class="s2">&quot;5-Z12&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span> <span class="s2">&quot;5-13&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span> <span class="s2">&quot;5-14&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span> <span class="s2">&quot;5-15&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span> <span class="s2">&quot;5-16&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span> <span class="s2">&quot;5-Z17&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span> <span class="s2">&quot;5-Z18&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span> <span class="s2">&quot;5-19&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span> <span class="s2">&quot;5-20&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span> <span class="s2">&quot;5-21&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span> <span class="s2">&quot;5-22&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span> <span class="s2">&quot;5-23&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span> <span class="s2">&quot;5-24&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span> <span class="s2">&quot;5-25&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span> <span class="s2">&quot;5-26&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span> <span class="s2">&quot;5-27&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span> <span class="s2">&quot;5-28&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span> <span class="s2">&quot;5-29&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span> <span class="s2">&quot;5-30&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">):</span> <span class="s2">&quot;5-31&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">):</span> <span class="s2">&quot;5-32&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span> <span class="s2">&quot;5-33&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">):</span> <span class="s2">&quot;5-34&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">):</span> <span class="s2">&quot;5-35&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span> <span class="s2">&quot;5-Z36&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span> <span class="s2">&quot;5-Z37&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span> <span class="s2">&quot;5-Z38&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span> <span class="s2">&quot;6-1&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span> <span class="s2">&quot;6-2&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span> <span class="s2">&quot;6-Z3&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span> <span class="s2">&quot;6-Z4&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span> <span class="s2">&quot;6-5&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span> <span class="s2">&quot;6-Z6&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span> <span class="s2">&quot;6-7&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span> <span class="s2">&quot;6-8&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span> <span class="s2">&quot;6-9&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span> <span class="s2">&quot;6-Z10&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span> <span class="s2">&quot;6-Z11&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span> <span class="s2">&quot;6-Z12&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span> <span class="s2">&quot;6-Z13&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span> <span class="s2">&quot;6-14&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span> <span class="s2">&quot;6-15&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span> <span class="s2">&quot;6-16&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span> <span class="s2">&quot;6-Z17&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span> <span class="s2">&quot;6-18&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span> <span class="s2">&quot;6-Z19&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">):</span> <span class="s2">&quot;6-20&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span> <span class="s2">&quot;6-21&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span> <span class="s2">&quot;6-22&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span> <span class="s2">&quot;6-Z23&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span> <span class="s2">&quot;6-Z24&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span> <span class="s2">&quot;6-Z25&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span> <span class="s2">&quot;6-Z26&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">):</span> <span class="s2">&quot;6-Z27&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">):</span> <span class="s2">&quot;6-Z28&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">):</span> <span class="s2">&quot;6-Z29&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">):</span> <span class="s2">&quot;6-30&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">):</span> <span class="s2">&quot;6-31&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">):</span> <span class="s2">&quot;6-32&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">):</span> <span class="s2">&quot;6-33&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">):</span> <span class="s2">&quot;6-34&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span> <span class="s2">&quot;6-35&quot;</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">PRIME_TO_FORTE</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">FORTE_CLASSES</span><span class="p">)</span>
<span class="n">FORTE_TO_PRIME</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">FORTE_CLASSES</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>


<div class="viewcode-block" id="forte_name">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.forte_name">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">forte_name</span><span class="p">(</span><span class="n">pc_set</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the Forte label for a pc-set, when the Forte class is defined.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This module currently stores canonical Forte labels for cardinalities 3..6.</span>
<span class="sd">    For cardinalities 7..9, the Forte label is derived from the complement&#39;s</span>
<span class="sd">    class label (same suffix), e.g. 7-35 complements 5-35.</span>

<span class="sd">    &gt;&gt;&gt; forte_name((0, 4, 7))</span>
<span class="sd">    &#39;3-11&#39;</span>
<span class="sd">    &gt;&gt;&gt; forte_name((0, 2, 4, 5, 7, 9, 11))</span>
<span class="sd">    &#39;7-35&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pcs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">pc_set</span><span class="p">)))</span>
    <span class="n">card</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pcs</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">3</span> <span class="o">&lt;=</span> <span class="n">card</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">pf</span> <span class="o">=</span> <span class="n">prime_form</span><span class="p">(</span><span class="n">pcs</span><span class="p">)</span>
    <span class="k">if</span> <span class="mi">3</span> <span class="o">&lt;=</span> <span class="n">card</span> <span class="o">&lt;=</span> <span class="mi">6</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">PRIME_TO_FORTE</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pf</span><span class="p">)</span>

    <span class="c1"># For 7..9, map via complement label: k-XX &lt;-&gt; (12-k)-XX</span>
    <span class="n">comp</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">pcs</span><span class="p">)))</span>
    <span class="n">comp_pf</span> <span class="o">=</span> <span class="n">prime_form</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span>
    <span class="n">comp_name</span> <span class="o">=</span> <span class="n">PRIME_TO_FORTE</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">comp_pf</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">comp_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">suffix</span> <span class="o">=</span> <span class="n">comp_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">card</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_forte_to_prime_form</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Map a Forte label to a representative prime form.</span>

<span class="sd">    Supports the module&#39;s 3..6 table directly and derives 7..9 labels via</span>
<span class="sd">    complement lookup.</span>

<span class="sd">    &gt;&gt;&gt; _forte_to_prime_form(&#39;3-11&#39;)</span>
<span class="sd">    (0, 3, 7)</span>
<span class="sd">    &gt;&gt;&gt; _forte_to_prime_form(&#39;7-35&#39;) == prime_form((0, 2, 4, 5, 7, 9, 11))</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span> <span class="ow">or</span> <span class="s2">&quot;-&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="n">head</span><span class="p">,</span> <span class="n">suffix</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">card</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="mi">3</span> <span class="o">&lt;=</span> <span class="n">card</span> <span class="o">&lt;=</span> <span class="mi">6</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">FORTE_TO_PRIME</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">if</span> <span class="mi">7</span> <span class="o">&lt;=</span> <span class="n">card</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">:</span>
        <span class="n">comp_card</span> <span class="o">=</span> <span class="mi">12</span> <span class="o">-</span> <span class="n">card</span>
        <span class="n">comp_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">comp_card</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">comp_pf</span> <span class="o">=</span> <span class="n">FORTE_TO_PRIME</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">comp_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">comp_pf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="c1"># Complement the representative and re-prime to land in the correct class.</span>
        <span class="n">rep</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">comp_pf</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">prime_form</span><span class="p">(</span><span class="n">rep</span><span class="p">)</span>

    <span class="k">return</span> <span class="kc">None</span>


<div class="viewcode-block" id="z_correspondent_prime_form">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.z_correspondent_prime_form">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">z_correspondent_prime_form</span><span class="p">(</span><span class="n">pf</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the Z-correspondent prime form (if any).</span>

<span class="sd">    Z-related pairs share the same interval vector but are not T/I-equivalent.</span>
<span class="sd">    (Forte Part 1 §1.9)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">pf</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="n">iv</span> <span class="o">=</span> <span class="n">interval_vector</span><span class="p">(</span><span class="n">pf</span><span class="p">)</span>
    <span class="n">candidates</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">p</span> <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">PRIME_TO_FORTE</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">interval_vector</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="n">iv</span> <span class="ow">and</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">pf</span>
    <span class="p">]</span>
    <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span> <span class="k">if</span> <span class="n">candidates</span> <span class="k">else</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="contains_abstract_subset">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.contains_abstract_subset">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">contains_abstract_subset</span><span class="p">(</span><span class="n">superset</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">subset</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if subset is contained in superset under some T_n or IT_n.</span>

<span class="sd">    This checks whether the subset can be found within the superset under any</span>
<span class="sd">    transposition or inversion-transposition operation. More sophisticated than</span>
<span class="sd">    simple subset checking.</span>

<span class="sd">    &gt;&gt;&gt; contains_abstract_subset((0, 4, 7), (0, 3))  # minor 3rd in major triad</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; contains_abstract_subset((0, 4, 7), (0, 2))  # major 2nd NOT in major triad</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; contains_abstract_subset((0, 2, 4, 5, 7, 9, 11), (0, 4, 7))  # major triad in major scale</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sup</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">superset</span><span class="p">)</span>
    <span class="n">sub</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">subset</span><span class="p">)</span>

    <span class="c1"># Try all 24 transformations (12 T_n + 12 IT_n)</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">transpose</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">sup</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">transpose</span><span class="p">(</span><span class="n">invert</span><span class="p">(</span><span class="n">sub</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">sup</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="kc">False</span></div>



<div class="viewcode-block" id="get_k_complex_size">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.get_k_complex_size">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_k_complex_size</span><span class="p">(</span><span class="n">pc_set</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Size of the K complex (includes sets related by abstract inclusion).</span>

<span class="sd">    The K complex is the set of all pitch-class sets that are related to the</span>
<span class="sd">    given set by abstract inclusion (subset/superset relations under T/I).</span>
<span class="sd">    This differs from Kh which requires reciprocal complement relations.</span>

<span class="sd">    &gt;&gt;&gt; get_k_complex_size((0, 4, 7))  # doctest: +SKIP</span>
<span class="sd">    100</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pcs</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">pc_set</span><span class="p">)</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4096</span><span class="p">):</span>
        <span class="n">candidate</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">int_to_pcset</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
        <span class="c1"># Check if candidate ⊆ pcs OR pcs ⊆ candidate (under any T/I)</span>
        <span class="k">if</span> <span class="n">contains_abstract_subset</span><span class="p">(</span><span class="n">pcs</span><span class="p">,</span> <span class="n">candidate</span><span class="p">)</span> <span class="ow">or</span> <span class="n">contains_abstract_subset</span><span class="p">(</span>
            <span class="n">candidate</span><span class="p">,</span> <span class="n">pcs</span>
        <span class="p">):</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">count</span></div>



<div class="viewcode-block" id="pc_set_convert">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.pc_set_convert">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">pc_set_convert</span><span class="p">(</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="n">to</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">from_repr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">on_error</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;raise&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert between pc-set representations.</span>

<span class="sd">    Supported reps: &#39;int&#39;, &#39;tuple&#39;, &#39;frozenset&#39;, &#39;set&#39;, &#39;forte&#39;, &#39;prime&#39;.</span>

<span class="sd">    &gt;&gt;&gt; pc_set_convert(145, &#39;tuple&#39;)</span>
<span class="sd">    (0, 4, 7)</span>
<span class="sd">    &gt;&gt;&gt; pc_set_convert((0, 4, 7), &#39;prime&#39;)</span>
<span class="sd">    (0, 3, 7)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_error</span><span class="p">(</span><span class="n">msg</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">on_error</span> <span class="o">==</span> <span class="s2">&quot;raise&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">from_repr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">from_repr</span> <span class="o">=</span> <span class="s2">&quot;int&quot;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">from_repr</span> <span class="o">=</span> <span class="s2">&quot;forte&quot;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">):</span>
            <span class="n">from_repr</span> <span class="o">=</span> <span class="s2">&quot;frozenset&quot;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
            <span class="n">from_repr</span> <span class="o">=</span> <span class="s2">&quot;set&quot;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="n">from_repr</span> <span class="o">=</span> <span class="s2">&quot;tuple&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot auto-detect representation for </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">from_repr</span> <span class="o">==</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">4096</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Integer </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> out of range [0, 4095]&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">from_repr</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;tuple&quot;</span><span class="p">,</span> <span class="s2">&quot;frozenset&quot;</span><span class="p">,</span> <span class="s2">&quot;set&quot;</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">pcset_to_int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">return</span> <span class="n">_error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid pc-set: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">from_repr</span> <span class="o">==</span> <span class="s2">&quot;forte&quot;</span><span class="p">:</span>
        <span class="n">pf</span> <span class="o">=</span> <span class="n">_forte_to_prime_form</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown Forte name: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">pcset_to_int</span><span class="p">(</span><span class="n">pf</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">from_repr</span> <span class="o">==</span> <span class="s2">&quot;prime&quot;</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">pcset_to_int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown source representation: </span><span class="si">{</span><span class="n">from_repr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">to</span> <span class="o">==</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n</span>
    <span class="k">if</span> <span class="n">to</span> <span class="o">==</span> <span class="s2">&quot;tuple&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_int_to_pcset</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">to</span> <span class="o">==</span> <span class="s2">&quot;frozenset&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">_int_to_pcset</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">to</span> <span class="o">==</span> <span class="s2">&quot;set&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">_int_to_pcset</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">to</span> <span class="o">==</span> <span class="s2">&quot;prime&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">prime_form</span><span class="p">(</span><span class="n">_int_to_pcset</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">to</span> <span class="o">==</span> <span class="s2">&quot;forte&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">forte_name</span><span class="p">(</span><span class="n">_int_to_pcset</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">_error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown target representation: </span><span class="si">{</span><span class="n">to</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="validate_prime_forms">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.validate_prime_forms">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">validate_prime_forms</span><span class="p">(</span><span class="n">nodes_df</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;Any&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;Any&quot;</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compare atonal prime_form() against Forte canonical forms.</span>

<span class="sd">    This validation function checks that the prime form computation in this</span>
<span class="sd">    module matches the canonical Forte prime forms for all 208 set classes</span>
<span class="sd">    (cardinality 3-9).</span>

<span class="sd">    Args:</span>
<span class="sd">        nodes_df: Optional pre-built nodes DataFrame. If None, builds it.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None if all prime forms match, otherwise a DataFrame of discrepancies.</span>

<span class="sd">    &gt;&gt;&gt; validate_prime_forms()  # doctest: +SKIP</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>

    <span class="c1"># Load or build reference data</span>
    <span class="k">if</span> <span class="n">nodes_df</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nodes_df</span> <span class="o">=</span> <span class="n">build_pcset_nodes_df</span><span class="p">()</span>

    <span class="c1"># Test all 208 Forte set classes (card 3-9)</span>
    <span class="n">forte_sets</span> <span class="o">=</span> <span class="n">nodes_df</span><span class="p">[</span>
        <span class="p">(</span><span class="n">nodes_df</span><span class="p">[</span><span class="s2">&quot;cardinality&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span>
        <span class="o">&amp;</span> <span class="p">(</span><span class="n">nodes_df</span><span class="p">[</span><span class="s2">&quot;cardinality&quot;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">)</span>
        <span class="o">&amp;</span> <span class="p">(</span><span class="n">nodes_df</span><span class="p">[</span><span class="s2">&quot;is_forte_set&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">True</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="n">discrepancies</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">forte_sets</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">pcset</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;pcset&quot;</span><span class="p">]</span>
        <span class="n">computed_prime</span> <span class="o">=</span> <span class="n">prime_form</span><span class="p">(</span><span class="n">pcset</span><span class="p">)</span>
        <span class="n">expected_prime</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;prime_form&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">computed_prime</span> <span class="o">!=</span> <span class="n">expected_prime</span><span class="p">:</span>
            <span class="n">discrepancies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="s2">&quot;forte_name&quot;</span><span class="p">:</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;forte_name&quot;</span><span class="p">],</span>
                    <span class="s2">&quot;input&quot;</span><span class="p">:</span> <span class="n">pcset</span><span class="p">,</span>
                    <span class="s2">&quot;computed&quot;</span><span class="p">:</span> <span class="n">computed_prime</span><span class="p">,</span>
                    <span class="s2">&quot;expected&quot;</span><span class="p">:</span> <span class="n">expected_prime</span><span class="p">,</span>
                <span class="p">}</span>
            <span class="p">)</span>

    <span class="k">if</span> <span class="n">discrepancies</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;WARNING: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">discrepancies</span><span class="p">)</span><span class="si">}</span><span class="s2"> prime form mismatches!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">discrepancies</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;✓ All prime forms match Forte canonical forms!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>



<span class="c1"># --- Dataset builders (nodes + links) ---------------------------------------</span>


<div class="viewcode-block" id="pcset_node_row">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.pcset_node_row">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">pcset_node_row</span><span class="p">(</span><span class="n">pc_set</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">/</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute a single nodes_df-style row for a pc-set.</span>

<span class="sd">    This is a convenience helper mirroring the per-row logic of</span>
<span class="sd">    :func:`build_pcset_nodes_df` without requiring pandas or enumerating all</span>
<span class="sd">    4096 sets.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pc_set:</span>
<span class="sd">        Either a 12-bit bitmap int (0..4095) or an iterable of pitch classes.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        A dict compatible with one row of ``build_pcset_nodes_df()``.</span>

<span class="sd">    &gt;&gt;&gt; row = pcset_node_row((0, 2, 4, 5, 7, 9, 11))</span>
<span class="sd">    &gt;&gt;&gt; row[&#39;forte_name&#39;]</span>
<span class="sd">    &#39;7-35&#39;</span>
<span class="sd">    &gt;&gt;&gt; row[&#39;id_&#39;] == pcset_to_int((0, 2, 4, 5, 7, 9, 11))</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pc_set</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pc_set</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">pcset_to_int</span><span class="p">(</span><span class="n">pc_set</span><span class="p">)</span>

    <span class="n">pcs</span> <span class="o">=</span> <span class="n">_int_to_pcset</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">card</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pcs</span><span class="p">)</span>
    <span class="n">comp</span> <span class="o">=</span> <span class="mi">4095</span> <span class="o">^</span> <span class="n">n</span>
    <span class="n">pf</span> <span class="o">=</span> <span class="n">prime_form</span><span class="p">(</span><span class="n">pcs</span><span class="p">)</span> <span class="k">if</span> <span class="n">pcs</span> <span class="k">else</span> <span class="p">()</span>
    <span class="n">iv</span> <span class="o">=</span> <span class="n">interval_vector</span><span class="p">(</span><span class="n">pcs</span><span class="p">)</span> <span class="k">if</span> <span class="n">pcs</span> <span class="k">else</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">fn</span> <span class="o">=</span> <span class="n">forte_name</span><span class="p">(</span><span class="n">pcs</span><span class="p">)</span>
    <span class="n">z_pf</span> <span class="o">=</span> <span class="n">z_correspondent_prime_form</span><span class="p">(</span><span class="n">pf</span><span class="p">)</span> <span class="k">if</span> <span class="n">pf</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="n">inv</span> <span class="o">=</span> <span class="n">max_invariance_degrees</span><span class="p">(</span><span class="n">pcs</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">{</span>
        <span class="s2">&quot;id_&quot;</span><span class="p">:</span> <span class="n">n</span><span class="p">,</span>
        <span class="s2">&quot;pcset&quot;</span><span class="p">:</span> <span class="n">pcs</span><span class="p">,</span>
        <span class="s2">&quot;cardinality&quot;</span><span class="p">:</span> <span class="n">card</span><span class="p">,</span>
        <span class="s2">&quot;contains_zero&quot;</span><span class="p">:</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">pcs</span><span class="p">,</span>
        <span class="s2">&quot;complement_id&quot;</span><span class="p">:</span> <span class="n">comp</span><span class="p">,</span>
        <span class="s2">&quot;prime_form&quot;</span><span class="p">:</span> <span class="n">pf</span><span class="p">,</span>
        <span class="s2">&quot;forte_name&quot;</span><span class="p">:</span> <span class="n">fn</span><span class="p">,</span>
        <span class="s2">&quot;is_forte_set&quot;</span><span class="p">:</span> <span class="nb">bool</span><span class="p">(</span><span class="n">pcs</span> <span class="ow">and</span> <span class="n">pcs</span> <span class="o">==</span> <span class="n">pf</span> <span class="ow">and</span> <span class="n">pf</span> <span class="ow">in</span> <span class="n">PRIME_TO_FORTE</span><span class="p">),</span>
        <span class="s2">&quot;interval_vector&quot;</span><span class="p">:</span> <span class="n">iv</span><span class="p">,</span>
        <span class="s2">&quot;is_t_symmetric&quot;</span><span class="p">:</span> <span class="n">is_transpositionally_symmetric</span><span class="p">(</span><span class="n">pcs</span><span class="p">)</span> <span class="k">if</span> <span class="n">pcs</span> <span class="k">else</span> <span class="kc">False</span><span class="p">,</span>
        <span class="s2">&quot;z_correspondent_prime_form&quot;</span><span class="p">:</span> <span class="n">z_pf</span><span class="p">,</span>
        <span class="s2">&quot;z_correspondent_forte_name&quot;</span><span class="p">:</span> <span class="n">PRIME_TO_FORTE</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">z_pf</span><span class="p">)</span> <span class="k">if</span> <span class="n">z_pf</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
        <span class="s2">&quot;n_T&quot;</span><span class="p">:</span> <span class="n">distinct_transpositions</span><span class="p">(</span><span class="n">pf</span> <span class="k">if</span> <span class="n">pf</span> <span class="k">else</span> <span class="n">pcs</span><span class="p">),</span>
        <span class="s2">&quot;n_I&quot;</span><span class="p">:</span> <span class="n">distinct_inversions</span><span class="p">(</span><span class="n">pf</span> <span class="k">if</span> <span class="n">pf</span> <span class="k">else</span> <span class="n">pcs</span><span class="p">),</span>
        <span class="s2">&quot;kh_size&quot;</span><span class="p">:</span> <span class="n">kh_complex_size</span><span class="p">(</span><span class="n">n</span><span class="p">),</span>
        <span class="s2">&quot;hexachord_combinatorial&quot;</span><span class="p">:</span> <span class="n">combinatorial_property_hexachord</span><span class="p">(</span><span class="n">pf</span> <span class="k">if</span> <span class="n">pf</span> <span class="k">else</span> <span class="n">pcs</span><span class="p">),</span>
        <span class="s2">&quot;max_T_invariance&quot;</span><span class="p">:</span> <span class="n">inv</span><span class="p">[</span><span class="s2">&quot;max_T_invariance&quot;</span><span class="p">],</span>
        <span class="s2">&quot;max_T_invariance_n&quot;</span><span class="p">:</span> <span class="n">inv</span><span class="p">[</span><span class="s2">&quot;max_T_invariance_n&quot;</span><span class="p">],</span>
        <span class="s2">&quot;max_I_invariance&quot;</span><span class="p">:</span> <span class="n">inv</span><span class="p">[</span><span class="s2">&quot;max_I_invariance&quot;</span><span class="p">],</span>
        <span class="s2">&quot;max_I_invariance_n&quot;</span><span class="p">:</span> <span class="n">inv</span><span class="p">[</span><span class="s2">&quot;max_I_invariance_n&quot;</span><span class="p">],</span>
        <span class="s2">&quot;best_normal_order&quot;</span><span class="p">:</span> <span class="n">best_normal_order</span><span class="p">(</span><span class="n">pcs</span><span class="p">),</span>
    <span class="p">}</span></div>



<div class="viewcode-block" id="build_pcset_nodes_df">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.build_pcset_nodes_df">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">build_pcset_nodes_df</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;Any&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Build nodes_df for all 4096 pc-sets with Forte-style fields.</span>

<span class="sd">    Returns a pandas DataFrame when pandas is installed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>  <span class="c1"># local import to keep module lightweight</span>

    <span class="n">rows</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4096</span><span class="p">):</span>
        <span class="n">pcs</span> <span class="o">=</span> <span class="n">_int_to_pcset</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">card</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pcs</span><span class="p">)</span>
        <span class="n">comp</span> <span class="o">=</span> <span class="mi">4095</span> <span class="o">^</span> <span class="n">n</span>
        <span class="n">pf</span> <span class="o">=</span> <span class="n">prime_form</span><span class="p">(</span><span class="n">pcs</span><span class="p">)</span> <span class="k">if</span> <span class="n">pcs</span> <span class="k">else</span> <span class="p">()</span>
        <span class="n">iv</span> <span class="o">=</span> <span class="n">interval_vector</span><span class="p">(</span><span class="n">pcs</span><span class="p">)</span> <span class="k">if</span> <span class="n">pcs</span> <span class="k">else</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">fn</span> <span class="o">=</span> <span class="n">forte_name</span><span class="p">(</span><span class="n">pcs</span><span class="p">)</span>

        <span class="n">z_pf</span> <span class="o">=</span> <span class="n">z_correspondent_prime_form</span><span class="p">(</span><span class="n">pf</span><span class="p">)</span> <span class="k">if</span> <span class="n">pf</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">inv</span> <span class="o">=</span> <span class="n">max_invariance_degrees</span><span class="p">(</span><span class="n">pcs</span><span class="p">)</span>

        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;id_&quot;</span><span class="p">:</span> <span class="n">n</span><span class="p">,</span>
                <span class="s2">&quot;pcset&quot;</span><span class="p">:</span> <span class="n">pcs</span><span class="p">,</span>
                <span class="s2">&quot;cardinality&quot;</span><span class="p">:</span> <span class="n">card</span><span class="p">,</span>
                <span class="s2">&quot;contains_zero&quot;</span><span class="p">:</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">pcs</span><span class="p">,</span>
                <span class="s2">&quot;complement_id&quot;</span><span class="p">:</span> <span class="n">comp</span><span class="p">,</span>
                <span class="s2">&quot;prime_form&quot;</span><span class="p">:</span> <span class="n">pf</span><span class="p">,</span>
                <span class="s2">&quot;forte_name&quot;</span><span class="p">:</span> <span class="n">fn</span><span class="p">,</span>
                <span class="s2">&quot;is_forte_set&quot;</span><span class="p">:</span> <span class="nb">bool</span><span class="p">(</span><span class="n">pcs</span> <span class="ow">and</span> <span class="n">pcs</span> <span class="o">==</span> <span class="n">pf</span> <span class="ow">and</span> <span class="n">pf</span> <span class="ow">in</span> <span class="n">PRIME_TO_FORTE</span><span class="p">),</span>
                <span class="s2">&quot;interval_vector&quot;</span><span class="p">:</span> <span class="n">iv</span><span class="p">,</span>
                <span class="s2">&quot;is_t_symmetric&quot;</span><span class="p">:</span> <span class="n">is_transpositionally_symmetric</span><span class="p">(</span><span class="n">pcs</span><span class="p">)</span> <span class="k">if</span> <span class="n">pcs</span> <span class="k">else</span> <span class="kc">False</span><span class="p">,</span>
                <span class="c1"># New fields requested</span>
                <span class="s2">&quot;z_correspondent_prime_form&quot;</span><span class="p">:</span> <span class="n">z_pf</span><span class="p">,</span>
                <span class="s2">&quot;z_correspondent_forte_name&quot;</span><span class="p">:</span> <span class="p">(</span>
                    <span class="n">PRIME_TO_FORTE</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">z_pf</span><span class="p">)</span> <span class="k">if</span> <span class="n">z_pf</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="p">),</span>
                <span class="s2">&quot;n_T&quot;</span><span class="p">:</span> <span class="n">distinct_transpositions</span><span class="p">(</span><span class="n">pf</span> <span class="k">if</span> <span class="n">pf</span> <span class="k">else</span> <span class="n">pcs</span><span class="p">),</span>
                <span class="s2">&quot;n_I&quot;</span><span class="p">:</span> <span class="n">distinct_inversions</span><span class="p">(</span><span class="n">pf</span> <span class="k">if</span> <span class="n">pf</span> <span class="k">else</span> <span class="n">pcs</span><span class="p">),</span>
                <span class="s2">&quot;kh_size&quot;</span><span class="p">:</span> <span class="n">kh_complex_size</span><span class="p">(</span><span class="n">n</span><span class="p">),</span>
                <span class="s2">&quot;hexachord_combinatorial&quot;</span><span class="p">:</span> <span class="n">combinatorial_property_hexachord</span><span class="p">(</span>
                    <span class="n">pf</span> <span class="k">if</span> <span class="n">pf</span> <span class="k">else</span> <span class="n">pcs</span>
                <span class="p">),</span>
                <span class="s2">&quot;max_T_invariance&quot;</span><span class="p">:</span> <span class="n">inv</span><span class="p">[</span><span class="s2">&quot;max_T_invariance&quot;</span><span class="p">],</span>
                <span class="s2">&quot;max_T_invariance_n&quot;</span><span class="p">:</span> <span class="n">inv</span><span class="p">[</span><span class="s2">&quot;max_T_invariance_n&quot;</span><span class="p">],</span>
                <span class="s2">&quot;max_I_invariance&quot;</span><span class="p">:</span> <span class="n">inv</span><span class="p">[</span><span class="s2">&quot;max_I_invariance&quot;</span><span class="p">],</span>
                <span class="s2">&quot;max_I_invariance_n&quot;</span><span class="p">:</span> <span class="n">inv</span><span class="p">[</span><span class="s2">&quot;max_I_invariance_n&quot;</span><span class="p">],</span>
                <span class="s2">&quot;best_normal_order&quot;</span><span class="p">:</span> <span class="n">best_normal_order</span><span class="p">(</span><span class="n">pcs</span><span class="p">),</span>
            <span class="p">}</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span></div>



<div class="viewcode-block" id="build_immediate_subset_links_df">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.build_immediate_subset_links_df">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">build_immediate_subset_links_df</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;Any&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Hasse-diagram edges: A -&gt; A ∪ {pc} for every missing pc.&quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>

    <span class="n">links</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4096</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">a</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">)):</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bit</span><span class="p">)</span>
                <span class="n">links</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;source&quot;</span><span class="p">:</span> <span class="n">a</span><span class="p">,</span> <span class="s2">&quot;target&quot;</span><span class="p">:</span> <span class="n">b</span><span class="p">})</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">links</span><span class="p">)</span></div>



<div class="viewcode-block" id="build_complement_links_df">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.build_complement_links_df">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">build_complement_links_df</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;Any&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Links between each set and its complement (half the pairs, undirected).&quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>

    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([{</span><span class="s2">&quot;source&quot;</span><span class="p">:</span> <span class="n">n</span><span class="p">,</span> <span class="s2">&quot;target&quot;</span><span class="p">:</span> <span class="mi">4095</span> <span class="o">^</span> <span class="n">n</span><span class="p">}</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2048</span><span class="p">)])</span></div>



<div class="viewcode-block" id="build_ti_equivalence_links_df">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.build_ti_equivalence_links_df">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">build_ti_equivalence_links_df</span><span class="p">(</span><span class="n">nodes_df</span><span class="p">:</span> <span class="s2">&quot;Any&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Any&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Links between all nodes in the same T/I set class (same prime form).&quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>

    <span class="n">links</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">nodes_df</span><span class="p">[</span><span class="n">nodes_df</span><span class="p">[</span><span class="s2">&quot;cardinality&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">groups</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;prime_form&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">groups</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="n">groups</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idxs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idxs</span><span class="p">,</span> <span class="s2">&quot;id_&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ids</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]:</span>
                <span class="n">links</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;source&quot;</span><span class="p">:</span> <span class="n">a</span><span class="p">,</span> <span class="s2">&quot;target&quot;</span><span class="p">:</span> <span class="n">b</span><span class="p">})</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">links</span><span class="p">)</span> <span class="k">if</span> <span class="n">links</span> <span class="k">else</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">,</span> <span class="s2">&quot;target&quot;</span><span class="p">])</span></div>



<div class="viewcode-block" id="build_z_relation_links_df">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.build_z_relation_links_df">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">build_z_relation_links_df</span><span class="p">(</span><span class="n">nodes_df</span><span class="p">:</span> <span class="s2">&quot;Any&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Any&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Links for Z-related pairs (same IV, different prime form).</span>

<span class="sd">    Adds columns: interval_vector, prime_form_a, prime_form_b.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>

    <span class="n">links</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">groups</span> <span class="o">=</span> <span class="n">nodes_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;interval_vector&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">groups</span>
    <span class="k">for</span> <span class="n">iv</span><span class="p">,</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="n">groups</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idxs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">nodes_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span>
        <span class="n">pfs</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="s2">&quot;prime_form&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pfs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="s2">&quot;id_&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ids</span><span class="p">):</span>
            <span class="n">pf_a</span> <span class="o">=</span> <span class="n">nodes_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">nodes_df</span><span class="p">[</span><span class="s2">&quot;id_&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">a</span><span class="p">,</span> <span class="s2">&quot;prime_form&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]:</span>
                <span class="n">pf_b</span> <span class="o">=</span> <span class="n">nodes_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">nodes_df</span><span class="p">[</span><span class="s2">&quot;id_&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">,</span> <span class="s2">&quot;prime_form&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">pf_a</span> <span class="o">!=</span> <span class="n">pf_b</span><span class="p">:</span>
                    <span class="n">links</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">{</span>
                            <span class="s2">&quot;source&quot;</span><span class="p">:</span> <span class="n">a</span><span class="p">,</span>
                            <span class="s2">&quot;target&quot;</span><span class="p">:</span> <span class="n">b</span><span class="p">,</span>
                            <span class="s2">&quot;interval_vector&quot;</span><span class="p">:</span> <span class="n">iv</span><span class="p">,</span>
                            <span class="s2">&quot;prime_form_a&quot;</span><span class="p">:</span> <span class="n">pf_a</span><span class="p">,</span>
                            <span class="s2">&quot;prime_form_b&quot;</span><span class="p">:</span> <span class="n">pf_b</span><span class="p">,</span>
                        <span class="p">}</span>
                    <span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">links</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">links</span>
        <span class="k">else</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">[</span>
                <span class="s2">&quot;source&quot;</span><span class="p">,</span>
                <span class="s2">&quot;target&quot;</span><span class="p">,</span>
                <span class="s2">&quot;interval_vector&quot;</span><span class="p">,</span>
                <span class="s2">&quot;prime_form_a&quot;</span><span class="p">,</span>
                <span class="s2">&quot;prime_form_b&quot;</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="p">)</span>
    <span class="p">)</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_inclusion_bitmask</span><span class="p">(</span><span class="n">set_a</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">set_b</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute 4-bit inclusion mask for K/Kh complex membership.</span>

<span class="sd">    Bit 0: A ⊂ B</span>
<span class="sd">    Bit 1: A ⊂ B&#39; (complement of B)</span>
<span class="sd">    Bit 2: B ⊂ A</span>
<span class="sd">    Bit 3: B ⊂ A&#39; (complement of A)</span>

<span class="sd">    Returns integer 0-15.</span>

<span class="sd">    Reference: Forte Part 2, §2.2 (&quot;The subcomplex Kh&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">set_a</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">set_b</span><span class="p">)</span>
    <span class="n">universe</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">))</span>
    <span class="n">a_comp</span> <span class="o">=</span> <span class="n">universe</span> <span class="o">-</span> <span class="n">a</span>
    <span class="n">b_comp</span> <span class="o">=</span> <span class="n">universe</span> <span class="o">-</span> <span class="n">b</span>

    <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">a</span> <span class="ow">and</span> <span class="n">b</span> <span class="ow">and</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">:</span>  <span class="c1"># proper subset</span>
        <span class="n">mask</span> <span class="o">|=</span> <span class="mb">0b0001</span>
    <span class="k">if</span> <span class="n">a</span> <span class="ow">and</span> <span class="n">b_comp</span> <span class="ow">and</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b_comp</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">|=</span> <span class="mb">0b0010</span>
    <span class="k">if</span> <span class="n">b</span> <span class="ow">and</span> <span class="n">a</span> <span class="ow">and</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">|=</span> <span class="mb">0b0100</span>
    <span class="k">if</span> <span class="n">b</span> <span class="ow">and</span> <span class="n">a_comp</span> <span class="ow">and</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">a_comp</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">|=</span> <span class="mb">0b1000</span>

    <span class="k">return</span> <span class="n">mask</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_max_common_subset_size</span><span class="p">(</span><span class="n">set_a</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">set_b</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Maximum size of subset shared between two sets under any T_n or I T_n.</span>

<span class="sd">    Used for R_p similarity relation (Forte Part 2, §2.4).</span>

<span class="sd">    &gt;&gt;&gt; _max_common_subset_size((0, 4, 7), (0, 3, 7))</span>
<span class="sd">    3</span>
<span class="sd">    &gt;&gt;&gt; _max_common_subset_size((0, 4, 7), (1, 5, 8))</span>
<span class="sd">    3</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">set_a</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">set_b</span><span class="p">)):</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">a</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">set_a</span><span class="p">)</span>
    <span class="n">max_common</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">):</span>
        <span class="c1"># T_n</span>
        <span class="n">b_tn</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">((</span><span class="n">p</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">set_b</span><span class="p">)</span>
        <span class="n">common</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span> <span class="o">&amp;</span> <span class="n">b_tn</span><span class="p">)</span>
        <span class="n">max_common</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_common</span><span class="p">,</span> <span class="n">common</span><span class="p">)</span>

        <span class="c1"># I T_n</span>
        <span class="n">b_itn</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">set_b</span><span class="p">)</span>
        <span class="n">common</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span> <span class="o">&amp;</span> <span class="n">b_itn</span><span class="p">)</span>
        <span class="n">max_common</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_common</span><span class="p">,</span> <span class="n">common</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">max_common</span>


<div class="viewcode-block" id="build_k_kh_links_df">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.build_k_kh_links_df">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">build_k_kh_links_df</span><span class="p">(</span><span class="n">nodes_df</span><span class="p">:</span> <span class="s2">&quot;Any&quot;</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">kh_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Any&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Build K or Kh complex links.</span>

<span class="sd">    For K: at least one inclusion relation holds among (A⊂B, A⊂B&#39;, B⊂A, B⊂A&#39;)</span>
<span class="sd">    For Kh: all four must hold (very restrictive)</span>

<span class="sd">    Reference: Forte Part 2, §2.2–2.3 (&quot;The subcomplex Kh&quot;, &quot;Set-Complex sizes&quot;)</span>

<span class="sd">    Args:</span>
<span class="sd">        nodes_df: The nodes dataframe</span>
<span class="sd">        kh_only: If True, only return Kh links (all 4 conditions met)</span>

<span class="sd">    Returns:</span>
<span class="sd">        DataFrame with columns: source, target, inclusion_mask</span>

<span class="sd">    &gt;&gt;&gt; # This is expensive, so skipping doctest</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>

    <span class="n">links</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Pre-extract pcsets for speed</span>
    <span class="n">pcsets</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;pcset&quot;</span><span class="p">])</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">nodes_df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">()]</span>
    <span class="n">ids</span> <span class="o">=</span> <span class="n">nodes_df</span><span class="p">[</span><span class="s2">&quot;id_&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="n">check</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="n">m</span> <span class="o">==</span> <span class="mb">0b1111</span><span class="p">)</span> <span class="k">if</span> <span class="n">kh_only</span> <span class="k">else</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Only check pairs where cardinalities could allow inclusion</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes_df</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">_inclusion_bitmask</span><span class="p">(</span><span class="n">pcsets</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">pcsets</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">check</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
                <span class="n">links</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">{</span>
                        <span class="s2">&quot;source&quot;</span><span class="p">:</span> <span class="n">ids</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                        <span class="s2">&quot;target&quot;</span><span class="p">:</span> <span class="n">ids</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                        <span class="s2">&quot;inclusion_mask&quot;</span><span class="p">:</span> <span class="n">mask</span><span class="p">,</span>
                    <span class="p">}</span>
                <span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">links</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">links</span>
        <span class="k">else</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">,</span> <span class="s2">&quot;target&quot;</span><span class="p">,</span> <span class="s2">&quot;inclusion_mask&quot;</span><span class="p">])</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="build_rp_similarity_links_df">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.build_rp_similarity_links_df">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">build_rp_similarity_links_df</span><span class="p">(</span>
    <span class="n">nodes_df</span><span class="p">:</span> <span class="s2">&quot;Any&quot;</span><span class="p">,</span> <span class="n">cardinality</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Any&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Build R_p similarity links for sets of a given cardinality.</span>

<span class="sd">    Two sets are R_p similar if they share n-1 pitch classes under some T_n or I T_n.</span>

<span class="sd">    Reference: Forte Part 2, §2.4 (&quot;Similarity relations&quot;)</span>

<span class="sd">    Args:</span>
<span class="sd">        nodes_df: The nodes dataframe</span>
<span class="sd">        cardinality: Optional cardinality to filter to (if None, process all)</span>

<span class="sd">    Returns:</span>
<span class="sd">        DataFrame with columns: source, target, max_common</span>

<span class="sd">    &gt;&gt;&gt; # This is expensive, so skipping doctest</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>

    <span class="k">if</span> <span class="n">cardinality</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">subset</span> <span class="o">=</span> <span class="n">nodes_df</span><span class="p">[</span><span class="n">nodes_df</span><span class="p">[</span><span class="s2">&quot;cardinality&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">cardinality</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">subset</span> <span class="o">=</span> <span class="n">nodes_df</span><span class="p">[</span><span class="n">nodes_df</span><span class="p">[</span><span class="s2">&quot;cardinality&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>

    <span class="n">pcsets</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s2">&quot;pcset&quot;</span><span class="p">])</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">subset</span><span class="o">.</span><span class="n">iterrows</span><span class="p">()]</span>
    <span class="n">ids</span> <span class="o">=</span> <span class="n">subset</span><span class="p">[</span><span class="s2">&quot;id_&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">cardinalities</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">pcs</span><span class="p">)</span> <span class="k">for</span> <span class="n">pcs</span> <span class="ow">in</span> <span class="n">pcsets</span><span class="p">]</span>

    <span class="n">links</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">id_a</span><span class="p">,</span> <span class="n">pcs_a</span><span class="p">,</span> <span class="n">card_a</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">pcsets</span><span class="p">,</span> <span class="n">cardinalities</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)):</span>
            <span class="n">id_b</span><span class="p">,</span> <span class="n">pcs_b</span><span class="p">,</span> <span class="n">card_b</span> <span class="o">=</span> <span class="n">ids</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">pcsets</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">cardinalities</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">card_a</span> <span class="o">!=</span> <span class="n">card_b</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">common</span> <span class="o">=</span> <span class="n">_max_common_subset_size</span><span class="p">(</span><span class="n">pcs_a</span><span class="p">,</span> <span class="n">pcs_b</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">common</span> <span class="o">==</span> <span class="n">card_a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">links</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">{</span>
                        <span class="s2">&quot;source&quot;</span><span class="p">:</span> <span class="n">id_a</span><span class="p">,</span>
                        <span class="s2">&quot;target&quot;</span><span class="p">:</span> <span class="n">id_b</span><span class="p">,</span>
                        <span class="s2">&quot;max_common&quot;</span><span class="p">:</span> <span class="n">common</span><span class="p">,</span>
                    <span class="p">}</span>
                <span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">links</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">links</span>
        <span class="k">else</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">,</span> <span class="s2">&quot;target&quot;</span><span class="p">,</span> <span class="s2">&quot;max_common&quot;</span><span class="p">])</span>
    <span class="p">)</span></div>



<span class="c1"># ---------------------------------------------------------------------------</span>
<span class="c1"># 1. PITCH-CLASS COMBINATIONS (THEORETICAL, ORDERLESS)</span>
<span class="c1"># ---------------------------------------------------------------------------</span>


<div class="viewcode-block" id="pc_combinations">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.pc_combinations">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">pc_combinations</span><span class="p">(</span>
    <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">pcs</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">)),</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">FrozenSet</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Enumerate all k-element pitch-class combinations from given pitch classes.</span>

<span class="sd">    This corresponds to the &quot;dumb upper bound&quot; level:</span>
<span class="sd">    choose k from 12, ignore order and octave.</span>

<span class="sd">    Args:</span>
<span class="sd">        k: number of pitch classes to choose (e.g. 3, 4, 5).</span>
<span class="sd">        pcs: iterable of pitch classes to choose from (default 0..11).</span>

<span class="sd">    Returns:</span>
<span class="sd">        List of frozensets, each a k-element pc-set.</span>

<span class="sd">    &gt;&gt;&gt; len(pc_combinations(3, range(12)))</span>
<span class="sd">    220</span>
<span class="sd">    &gt;&gt;&gt; frozenset({0, 4, 7}) in pc_combinations(3)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="n">pcs</span><span class="p">,</span> <span class="n">k</span><span class="p">)]</span></div>



<div class="viewcode-block" id="all_pc_combinations">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.all_pc_combinations">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">all_pc_combinations</span><span class="p">(</span>
    <span class="n">sizes</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
    <span class="n">pcs</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">)),</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">FrozenSet</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Enumerate all pitch-class combinations for the given sizes.</span>

<span class="sd">    &gt;&gt;&gt; combos = all_pc_combinations((3, 4))</span>
<span class="sd">    &gt;&gt;&gt; len(combos)  # 220 + 495 = 715</span>
<span class="sd">    715</span>
<span class="sd">    &gt;&gt;&gt; frozenset({0, 3, 7}) in combos</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">FrozenSet</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sizes</span><span class="p">:</span>
        <span class="n">out</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pc_combinations</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">pcs</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">out</span></div>



<span class="c1"># ---------------------------------------------------------------------------</span>
<span class="c1"># 2. VOICING ENUMERATION IN A BOUNDED RANGE</span>
<span class="c1"># ---------------------------------------------------------------------------</span>


<div class="viewcode-block" id="interval_stack_voicings">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.interval_stack_voicings">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">interval_stack_voicings</span><span class="p">(</span>
    <span class="n">root</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">max_semitones</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">24</span><span class="p">,</span>
    <span class="n">allowed_intervals</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">),</span>
    <span class="n">max_notes</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="n">min_notes</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Enumerate voicings by *stacking intervals* above a root, staying within</span>
<span class="sd">    `max_semitones`.</span>

<span class="sd">    The algorithm:</span>
<span class="sd">        - start with [root]</span>
<span class="sd">        - at each step add one of allowed_intervals to the *last* pitch</span>
<span class="sd">        - stop when adding any allowed interval would go past max_semitones</span>
<span class="sd">        - keep sequences whose length is between min_notes and max_notes</span>

<span class="sd">    This is *exactly* the &quot;fixed root, bounded range, interval stacking&quot;</span>
<span class="sd">    approach you described.</span>

<span class="sd">    Args:</span>
<span class="sd">        root: base pitch (0 means &#39;C&#39; abstractly).</span>
<span class="sd">        max_semitones: highest allowed pitch = root + max_semitones.</span>
<span class="sd">        allowed_intervals: intervals (in semitones) you can stack.</span>
<span class="sd">        max_notes: maximum size of the voicing.</span>
<span class="sd">        min_notes: minimum size of the voicing.</span>

<span class="sd">    Returns:</span>
<span class="sd">        List of tuples, each a voicing like (0, 4, 7) or (0, 5, 9, 12).</span>

<span class="sd">    &gt;&gt;&gt; v = interval_stack_voicings(</span>
<span class="sd">    ...     root=0,</span>
<span class="sd">    ...     max_semitones=12,</span>
<span class="sd">    ...     allowed_intervals=(3, 4, 5),</span>
<span class="sd">    ...     max_notes=4,</span>
<span class="sd">    ...     min_notes=3,</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; (0, 4, 7) in v or (0, 3, 7) in v</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">results</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_recur</span><span class="p">(</span><span class="n">current</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">min_notes</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">max_notes</span><span class="p">:</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">max_notes</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">last</span> <span class="o">=</span> <span class="n">current</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">iv</span> <span class="ow">in</span> <span class="n">allowed_intervals</span><span class="p">:</span>
            <span class="n">nxt</span> <span class="o">=</span> <span class="n">last</span> <span class="o">+</span> <span class="n">iv</span>
            <span class="k">if</span> <span class="n">nxt</span> <span class="o">-</span> <span class="n">root</span> <span class="o">&gt;</span> <span class="n">max_semitones</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">current</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nxt</span><span class="p">)</span>
            <span class="n">_recur</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
            <span class="n">current</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="n">_recur</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">results</span></div>



<div class="viewcode-block" id="expand_with_duplicates">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.expand_with_duplicates">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">expand_with_duplicates</span><span class="p">(</span>
    <span class="n">base_voicing</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
    <span class="n">max_duplicates</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">within</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">24</span><span class="p">),</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a voicing like (0, 4, 7), add (at most) `max_duplicates` extra notes</span>
<span class="sd">    that duplicate existing pitch classes in nearby octaves.</span>

<span class="sd">    This models the real-life situation where pianists double the root or the</span>
<span class="sd">    fifth.</span>

<span class="sd">    Args:</span>
<span class="sd">        base_voicing: base tuple of pitches (sorted, ascending).</span>
<span class="sd">        max_duplicates: how many extra notes to add at most.</span>
<span class="sd">        within: (lo, hi) absolute pitch bounds.</span>

<span class="sd">    Returns:</span>
<span class="sd">        List of voicings, including the original one.</span>

<span class="sd">    &gt;&gt;&gt; expand_with_duplicates((0, 4, 7), max_duplicates=1, within=(0, 12))</span>
<span class="sd">    [(0, 4, 7), (0, 4, 7, 12)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">base</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">base_voicing</span><span class="p">))</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">base</span><span class="p">]</span>

    <span class="c1"># Find candidate duplicates: transpose existing notes by octaves</span>
    <span class="n">candidates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">base</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">octv</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>  <span class="c1"># generous</span>
            <span class="n">cand</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">12</span> <span class="o">*</span> <span class="n">octv</span>
            <span class="k">if</span> <span class="n">within</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">cand</span> <span class="o">&lt;=</span> <span class="n">within</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">cand</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">base</span><span class="p">:</span>
                <span class="n">candidates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cand</span><span class="p">)</span>

    <span class="c1"># pick up to max_duplicates from candidates</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_duplicates</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">extra</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
            <span class="n">new_v</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">extra</span><span class="p">))</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_v</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">out</span></div>



<span class="c1"># ---------------------------------------------------------------------------</span>
<span class="c1"># 3. LINKING / GRAPH CONSTRUCTION</span>
<span class="c1"># ---------------------------------------------------------------------------</span>


<div class="viewcode-block" id="shared_pcs">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.shared_pcs">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">shared_pcs</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">b</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Number of shared pitch classes between two voicings.</span>

<span class="sd">    &gt;&gt;&gt; shared_pcs((0, 4, 7), (0, 7, 11))</span>
<span class="sd">    2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">({</span><span class="n">x</span> <span class="o">%</span> <span class="mi">12</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span><span class="p">}</span><span class="o">.</span><span class="n">intersection</span><span class="p">({</span><span class="n">y</span> <span class="o">%</span> <span class="mi">12</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">b</span><span class="p">}))</span></div>



<div class="viewcode-block" id="voice_leading_distance">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.voice_leading_distance">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">voice_leading_distance</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">b</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A dumb voice-leading distance: compare two voicings of (possibly) the same</span>
<span class="sd">    length, and sum absolute differences between *best-matched* notes.</span>

<span class="sd">    For simplicity, if lengths differ, we match up to the min length.</span>

<span class="sd">    This is *not* Tymoczko&#39;s metric, but good enough for building edges.</span>

<span class="sd">    &gt;&gt;&gt; voice_leading_distance((0, 4, 7), (0, 5, 7))</span>
<span class="sd">    1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">la</span><span class="p">,</span> <span class="n">lb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">la</span><span class="p">,</span> <span class="n">lb</span><span class="p">)</span>
    <span class="c1"># naive: sort and zip</span>
    <span class="n">sa</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">a</span><span class="p">)[:</span><span class="n">m</span><span class="p">]</span>
    <span class="n">sb</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">b</span><span class="p">)[:</span><span class="n">m</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sa</span><span class="p">,</span> <span class="n">sb</span><span class="p">))</span></div>



<div class="viewcode-block" id="is_subset_pcs">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.is_subset_pcs">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">is_subset_pcs</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">b</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    True if pc(a) is subset of pc(b).</span>

<span class="sd">    &gt;&gt;&gt; is_subset_pcs((0, 4, 7), (0, 2, 4, 7, 9))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_subset_pcs((0, 4, 7), (1, 4, 7))</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">x</span> <span class="o">%</span> <span class="mi">12</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span><span class="p">}</span><span class="o">.</span><span class="n">issubset</span><span class="p">({</span><span class="n">y</span> <span class="o">%</span> <span class="mi">12</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">b</span><span class="p">})</span></div>



<div class="viewcode-block" id="is_codiatonic">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.is_codiatonic">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">is_codiatonic</span><span class="p">(</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
    <span class="n">b</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
    <span class="n">scale_quality</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">),</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">tonic</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return True if the union of the pitch classes of chords `a` and `b`</span>
<span class="sd">    can be embedded in a single scale derived from the given `scale_quality`.</span>

<span class="sd">    If `tonic` is provided (0–11), only test that transposition of the scale;</span>
<span class="sd">    otherwise, test all 12 possible transpositions.</span>

<span class="sd">    Args:</span>
<span class="sd">        a: chord as a tuple of pitches (any integers)</span>
<span class="sd">        b: chord as a tuple of pitches (any integers)</span>
<span class="sd">        scale_quality: sequence of pitch-class intervals for the scale (default: major)</span>
<span class="sd">        tonic: if not None, only use this tonic (0-11), else try all 12 transpositions</span>

<span class="sd">    Returns:</span>
<span class="sd">        True if union of a and b&#39;s pitch classes is a subset of any transposition of the scale.</span>

<span class="sd">    &gt;&gt;&gt; is_codiatonic((0, 4, 7), (2, 5, 9))  # e.g. C major triad + D minor triad, both in C major</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_codiatonic((0, 4, 7), (1, 5, 8))  # No two major triads a semitone apart in major scales...</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_codiatonic((0, 4, 7), (1, 5, 8), scale_quality=(0,2,3,5,7,8,11))  # ... but in a harmonic minor, there are</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_codiatonic((0, 4, 7), (1, 4, 8), tonic=0)  # Only test C major scale</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_codiatonic((0, 4, 7), (1, 4, 8), tonic=1)  # Only test C# major scale</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_codiatonic((0, 4, 7), (2, 5, 9), tonic=0)  # C major scale, C and Dm triads</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pcs_union</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span> <span class="o">%</span> <span class="mi">12</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span><span class="p">}</span> <span class="o">|</span> <span class="p">{</span><span class="n">y</span> <span class="o">%</span> <span class="mi">12</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">b</span><span class="p">}</span>
    <span class="n">scale_quality_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">x</span> <span class="o">%</span> <span class="mi">12</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">scale_quality</span><span class="p">)</span>
    <span class="c1"># Precompute all 12 transpositions of the scale as sets</span>
    <span class="k">if</span> <span class="n">tonic</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tonics</span> <span class="o">=</span> <span class="p">[</span><span class="n">tonic</span> <span class="o">%</span> <span class="mi">12</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tonics</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tonics</span><span class="p">:</span>
        <span class="n">scale_pcs</span> <span class="o">=</span> <span class="p">{(</span><span class="n">p</span> <span class="o">+</span> <span class="n">t</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">scale_quality_set</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">pcs_union</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">scale_pcs</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span></div>



<div class="viewcode-block" id="build_graph">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.build_graph">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">build_graph</span><span class="p">(</span>
    <span class="n">voicings</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">min_shared_pcs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">max_vl_distance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">include_subset_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build an adjacency list over voicings using several criteria.</span>

<span class="sd">    A directed edge i -&gt; j is created if ANY of the following are true:</span>
<span class="sd">      - shared PCs &gt;= min_shared_pcs</span>
<span class="sd">      - voice-leading distance &lt;= max_vl_distance (if given)</span>
<span class="sd">      - i is pc-subset of j (if include_subset_edges)</span>

<span class="sd">    Args:</span>
<span class="sd">        voicings: list of voicings (each is a tuple of ints)</span>
<span class="sd">        min_shared_pcs: minimum shared pitch classes to create an edge</span>
<span class="sd">        max_vl_distance: max voice-leading distance, or None to ignore</span>
<span class="sd">        include_subset_edges: whether to link subset -&gt; superset</span>

<span class="sd">    Returns:</span>
<span class="sd">        Dict[node_index, List[node_index]]</span>

<span class="sd">    &gt;&gt;&gt; V = [(0, 4, 7), (0, 5, 7), (0, 4, 7, 11)]</span>
<span class="sd">    &gt;&gt;&gt; G = build_graph(V, min_shared_pcs=2)</span>
<span class="sd">    &gt;&gt;&gt; sorted(G[0])</span>
<span class="sd">    [1, 2]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">voicings</span><span class="p">)</span>
    <span class="n">adj</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)}</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">voicings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">voicings</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">add_edge</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="n">shared_pcs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">min_shared_pcs</span><span class="p">:</span>
                <span class="n">add_edge</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">max_vl_distance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">voice_leading_distance</span><span class="p">(</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
            <span class="p">)</span> <span class="o">&lt;=</span> <span class="n">max_vl_distance</span><span class="p">:</span>
                <span class="n">add_edge</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="n">include_subset_edges</span> <span class="ow">and</span> <span class="n">is_subset_pcs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
                <span class="n">add_edge</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="n">add_edge</span><span class="p">:</span>
                <span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">adj</span></div>



<span class="c1"># ---------------------------------------------------------------------------</span>
<span class="c1"># 4. HIGHER-LEVEL GENERATORS</span>
<span class="c1"># ---------------------------------------------------------------------------</span>


<div class="viewcode-block" id="generate_default_voicing_space">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.generate_default_voicing_space">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">generate_default_voicing_space</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a reasonably rich but still small voicing space:</span>

<span class="sd">    - root = 0 (C)</span>
<span class="sd">    - range = 24 semitones (two octaves)</span>
<span class="sd">    - allowed intervals = 2, 3, 4, 5, 7</span>
<span class="sd">    - 3 to 5 notes</span>
<span class="sd">    - plus optional duplications</span>

<span class="sd">    &gt;&gt;&gt; V = generate_default_voicing_space()</span>
<span class="sd">    &gt;&gt;&gt; isinstance(V, list) and len(V) &gt; 50</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">base</span> <span class="o">=</span> <span class="n">interval_stack_voicings</span><span class="p">(</span>
        <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">max_semitones</span><span class="o">=</span><span class="mi">24</span><span class="p">,</span>
        <span class="n">allowed_intervals</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span>
        <span class="n">max_notes</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
        <span class="n">min_notes</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="c1"># optionally expand some of them with duplicates</span>
    <span class="n">expanded</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">base</span><span class="p">:</span>
        <span class="n">expanded</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">expand_with_duplicates</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">max_duplicates</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">within</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">24</span><span class="p">)))</span>
    <span class="c1"># deduplicate</span>
    <span class="n">uniq</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">expanded</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">uniq</span></div>



<div class="viewcode-block" id="generate_graph_default">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.generate_graph_default">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">generate_graph_default</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convenience: generate a default voicing space and link it.</span>

<span class="sd">    &gt;&gt;&gt; G = generate_graph_default()  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt; len(G) &gt; 50  # doctest: +SKIP</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">generate_default_voicing_space</span><span class="p">()</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">build_graph</span><span class="p">(</span>
        <span class="n">V</span><span class="p">,</span>
        <span class="n">min_shared_pcs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">max_vl_distance</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="n">include_subset_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">G</span></div>



<span class="c1"># ---------------------------------------------------------------------------</span>
<span class="c1"># 5. NOTES ON EXTENSIONS (not code, but pointers)</span>
<span class="c1"># ---------------------------------------------------------------------------</span>
<span class="c1"># - To include *all 12 transpositions*, just add 0..11 to every pitch.</span>
<span class="c1"># - To include *different roots*, call interval_stack_voicings with root=0..11</span>
<span class="c1">#   and merge the results.</span>
<span class="c1"># - To restrict to &quot;actual&quot; tonal chord qualities, prefilter voicings whose</span>
<span class="c1">#   pitch classes match {0,4,7}, {0,3,7}, {0,4,7,11}, etc.</span>
<span class="c1"># - To get Forte-style pc-set categories, you’d add a normalization function</span>
<span class="c1">#   that maps pitch-class sets to prime form and use that as node label.</span>


<span class="c1"># ---------------------------------------------------------------------------</span>
<span class="c1"># CHORD TABLES AND LINK COMPUTATION</span>
<span class="c1"># ---------------------------------------------------------------------------</span>

<span class="c1"># Global configuration for computation warnings</span>
<span class="n">DEFAULT_WARNING_THRESHOLD</span> <span class="o">=</span> <span class="mi">10000</span>  <span class="c1"># warn if processing more than this many combinations</span>


<div class="viewcode-block" id="transitive_reduction_links">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.transitive_reduction_links">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">transitive_reduction_links</span><span class="p">(</span>
    <span class="n">adjacency</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">require_dag</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute a transitive reduction of a directed graph given as adjacency lists.</span>

<span class="sd">    This removes an edge $u \to v$ if there exists an alternate path from $u$ to</span>
<span class="sd">    $v$ of length $\ge 2$.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - For DAGs, the transitive reduction is unique.</span>
<span class="sd">        - For graphs with cycles, transitive reduction is not unique; by default</span>
<span class="sd">          this function refuses cyclic graphs.</span>

<span class="sd">    Args:</span>
<span class="sd">        adjacency: adjacency lists indexed by node index.</span>
<span class="sd">        require_dag: if True, raise ValueError when cycles are detected.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A new adjacency list with transitive edges removed.</span>

<span class="sd">    &gt;&gt;&gt; adj = [[1, 2], [2], []]  # 0-&gt;1-&gt;2 and 0-&gt;2 (transitive)</span>
<span class="sd">    &gt;&gt;&gt; transitive_reduction_links(adj)</span>
<span class="sd">    [[1], [2], []]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">adj</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">neigh</span><span class="p">))</span> <span class="k">for</span> <span class="n">neigh</span> <span class="ow">in</span> <span class="n">adjacency</span><span class="p">]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">adj</span><span class="p">)</span>

    <span class="n">topo</span> <span class="o">=</span> <span class="n">_topological_order</span><span class="p">(</span><span class="n">adj</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">topo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">require_dag</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Graph has cycles; transitive reduction is ambiguous. &quot;</span>
                <span class="s2">&quot;Set require_dag=False to proceed anyway (not recommended).&quot;</span>
            <span class="p">)</span>
        <span class="c1"># Fallback: conservative removal using per-edge reachability checks.</span>
        <span class="k">return</span> <span class="n">_transitive_reduction_general</span><span class="p">(</span><span class="n">adj</span><span class="p">)</span>

    <span class="c1"># Compute reachability sets in reverse topological order</span>
    <span class="n">reachable</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">topo</span><span class="p">):</span>
        <span class="n">r</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="n">r</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">|=</span> <span class="n">reachable</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
        <span class="n">reachable</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>

    <span class="n">reduced</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">out_u</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">])</span>
        <span class="n">closure_by_child</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span><span class="n">w</span><span class="p">:</span> <span class="p">({</span><span class="n">w</span><span class="p">}</span> <span class="o">|</span> <span class="n">reachable</span><span class="p">[</span><span class="n">w</span><span class="p">])</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">out_u</span><span class="p">}</span>

        <span class="n">kept</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">out_u</span><span class="p">:</span>
            <span class="c1"># Remove u-&gt;v if v is reachable via some other outgoing neighbor.</span>
            <span class="n">implied</span> <span class="o">=</span> <span class="nb">any</span><span class="p">((</span><span class="n">w</span> <span class="o">!=</span> <span class="n">v</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">v</span> <span class="ow">in</span> <span class="n">closure_by_child</span><span class="p">[</span><span class="n">w</span><span class="p">])</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">out_u</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">implied</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">kept</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">reduced</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kept</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">reduced</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_topological_order</span><span class="p">(</span><span class="n">adjacency</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a topological order if graph is a DAG, else None.&quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">adjacency</span><span class="p">)</span>
    <span class="n">indeg</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">adjacency</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">indeg</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indeg</span><span class="p">)</span> <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">order</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">adjacency</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="n">indeg</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">indeg</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">order</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">order</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_transitive_reduction_general</span><span class="p">(</span>
    <span class="n">adjacency</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Conservative transitive reduction for general directed graphs.</span>

<span class="sd">    This removes edge u-&gt;v if v is reachable from u without using that edge.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">adj</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">neigh</span><span class="p">))</span> <span class="k">for</span> <span class="n">neigh</span> <span class="ow">in</span> <span class="n">adjacency</span><span class="p">]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">adj</span><span class="p">)</span>
    <span class="n">reduced</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">kept</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="c1"># BFS from u, skipping the direct edge u-&gt;v</span>
            <span class="n">seen</span> <span class="o">=</span> <span class="p">{</span><span class="n">u</span><span class="p">}</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="k">if</span> <span class="n">w</span> <span class="o">!=</span> <span class="n">v</span><span class="p">]</span>
            <span class="n">reachable</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">while</span> <span class="n">stack</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">reachable</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">v</span><span class="p">:</span>
                    <span class="n">reachable</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">adj</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">reachable</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">kept</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">reduced</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kept</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">reduced</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_warn_if_large_computation</span><span class="p">(</span>
    <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">DEFAULT_WARNING_THRESHOLD</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Warn user if computation might take a while.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;⚠️  Processing </span><span class="si">{</span><span class="n">n</span><span class="si">:</span><span class="s2">,</span><span class="si">}</span><span class="s2"> items. This may take a while...&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<div class="viewcode-block" id="chord_table">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.chord_table">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">chord_table</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">voicings</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">id_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;id_&quot;</span><span class="p">,</span>
    <span class="n">index_by</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span>
    <span class="n">include_links</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">link_kinds</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">use_pandas</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">warning_threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">DEFAULT_WARNING_THRESHOLD</span><span class="p">,</span>
    <span class="o">**</span><span class="n">link_kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build a chord table with one row per chord.</span>

<span class="sd">    By default, generates the default voicing space from atonal.base.</span>
<span class="sd">    Each row describes the chord&#39;s internal features: voicing, number of notes,</span>
<span class="sd">    span, pitch-class set, and interval vector.</span>

<span class="sd">    If `include_links` is True, link columns are added listing linked chord IDs</span>
<span class="sd">    according to the specified link kinds.</span>

<span class="sd">    Args:</span>
<span class="sd">        voicings: list of chord tuples (if None, use generate_default_voicing_space()).</span>
<span class="sd">        id_col: name of the unique ID column.</span>
<span class="sd">        index_by: how to compute chord IDs (&quot;int&quot;, &quot;hash&quot;, or &quot;repr&quot;).</span>
<span class="sd">        include_links: whether to add link columns.</span>
<span class="sd">        link_kinds: types of links to compute if include_links is True</span>
<span class="sd">            (e.g., [&quot;shared&quot;, &quot;subset&quot;, &quot;voiceleading&quot;]).</span>
<span class="sd">        use_pandas: return DataFrame if True, otherwise yield dicts.</span>
<span class="sd">        warning_threshold: threshold for warning about large computations.</span>
<span class="sd">        **link_kwargs: passed to compute_links for each link kind.</span>

<span class="sd">    Returns:</span>
<span class="sd">        pandas.DataFrame if use_pandas else generator of dicts</span>

<span class="sd">    &gt;&gt;&gt; table = list(chord_table(</span>
<span class="sd">    ...     voicings=[(0, 4, 7), (0, 3, 7), (0, 4, 7, 11)],</span>
<span class="sd">    ...     use_pandas=False</span>
<span class="sd">    ... ))</span>
<span class="sd">    &gt;&gt;&gt; len(table)</span>
<span class="sd">    3</span>
<span class="sd">    &gt;&gt;&gt; table[0][&#39;n_notes&#39;]</span>
<span class="sd">    3</span>
<span class="sd">    &gt;&gt;&gt; table[0][&#39;span&#39;]</span>
<span class="sd">    7</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># 1. Get voicings</span>
    <span class="k">if</span> <span class="n">voicings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">voicings</span> <span class="o">=</span> <span class="n">generate_default_voicing_space</span><span class="p">()</span>

    <span class="n">_warn_if_large_computation</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">voicings</span><span class="p">),</span> <span class="n">warning_threshold</span><span class="p">)</span>

    <span class="c1"># 2. Assign IDs based on index_by strategy</span>
    <span class="n">ids</span> <span class="o">=</span> <span class="n">_generate_ids</span><span class="p">(</span><span class="n">voicings</span><span class="p">,</span> <span class="n">index_by</span><span class="p">)</span>

    <span class="c1"># 3. Generate chord feature rows</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_chord_feature_rows</span><span class="p">(</span><span class="n">voicings</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">id_col</span><span class="p">))</span>

    <span class="c1"># 4. Add links if requested</span>
    <span class="k">if</span> <span class="n">include_links</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">link_kinds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">link_kinds</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;shared&quot;</span><span class="p">]</span>  <span class="c1"># default to shared PC links</span>

        <span class="k">for</span> <span class="n">kind</span> <span class="ow">in</span> <span class="n">link_kinds</span><span class="p">:</span>
            <span class="n">_warn_if_large_computation</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">),</span>
                <span class="n">warning_threshold</span> <span class="o">*</span> <span class="mi">100</span><span class="p">,</span>  <span class="c1"># pairwise is more expensive</span>
            <span class="p">)</span>
            <span class="n">links</span> <span class="o">=</span> <span class="n">compute_links</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">id_col</span><span class="o">=</span><span class="n">id_col</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="o">**</span><span class="n">link_kwargs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">row</span><span class="p">,</span> <span class="n">link_list</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">links</span><span class="p">):</span>
                <span class="n">row</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">kind</span><span class="si">}</span><span class="s2">_links&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">link_list</span>

    <span class="c1"># 5. Produce output</span>
    <span class="k">if</span> <span class="n">use_pandas</span><span class="p">:</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>

        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">row</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">)</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_generate_ids</span><span class="p">(</span><span class="n">voicings</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span> <span class="n">index_by</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate IDs for voicings based on indexing strategy.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">index_by</span> <span class="o">==</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">voicings</span><span class="p">)))</span>
    <span class="k">elif</span> <span class="n">index_by</span> <span class="o">==</span> <span class="s2">&quot;hash&quot;</span><span class="p">:</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">hashlib</span>

        <span class="k">return</span> <span class="p">[</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">hashlib</span><span class="o">.</span><span class="n">sha1</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">(),</span> <span class="mi">16</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">12</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">voicings</span>
        <span class="p">]</span>
    <span class="k">elif</span> <span class="n">index_by</span> <span class="o">==</span> <span class="s2">&quot;repr&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="nb">repr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">voicings</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Unknown index_by mode: </span><span class="si">{</span><span class="n">index_by</span><span class="si">}</span><span class="s2">. Must be &#39;int&#39;, &#39;hash&#39;, or &#39;repr&#39;.&quot;</span>
        <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_chord_feature_rows</span><span class="p">(</span>
    <span class="n">voicings</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span> <span class="n">ids</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span> <span class="n">id_col</span><span class="p">:</span> <span class="nb">str</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate chord feature dicts for each voicing.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">chord_id</span><span class="p">,</span> <span class="n">voicing</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">voicings</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">_chord_features</span><span class="p">(</span><span class="n">chord_id</span><span class="p">,</span> <span class="n">voicing</span><span class="p">,</span> <span class="n">id_col</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_chord_features</span><span class="p">(</span><span class="n">chord_id</span><span class="p">,</span> <span class="n">voicing</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">id_col</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract features from a single chord voicing.&quot;&quot;&quot;</span>
    <span class="n">pcs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">({</span><span class="n">p</span> <span class="o">%</span> <span class="mi">12</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">voicing</span><span class="p">})</span>
    <span class="n">n_notes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">voicing</span><span class="p">)</span>

    <span class="c1"># Interval vector: count each interval class (1-6) in the pc-set</span>
    <span class="n">interval_vector</span> <span class="o">=</span> <span class="n">_compute_interval_vector</span><span class="p">(</span><span class="n">pcs</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">{</span>
        <span class="n">id_col</span><span class="p">:</span> <span class="n">chord_id</span><span class="p">,</span>
        <span class="s2">&quot;voicing&quot;</span><span class="p">:</span> <span class="n">voicing</span><span class="p">,</span>
        <span class="s2">&quot;n_notes&quot;</span><span class="p">:</span> <span class="n">n_notes</span><span class="p">,</span>
        <span class="s2">&quot;span&quot;</span><span class="p">:</span> <span class="nb">max</span><span class="p">(</span><span class="n">voicing</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">voicing</span><span class="p">)</span> <span class="k">if</span> <span class="n">n_notes</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;pitch_classes&quot;</span><span class="p">:</span> <span class="n">pcs</span><span class="p">,</span>
        <span class="s2">&quot;n_pcs&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">pcs</span><span class="p">),</span>
        <span class="s2">&quot;interval_vector&quot;</span><span class="p">:</span> <span class="n">interval_vector</span><span class="p">,</span>
    <span class="p">}</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_compute_interval_vector</span><span class="p">(</span><span class="n">pcs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the interval vector for a pitch-class set.</span>

<span class="sd">    The interval vector counts occurrences of each interval class (1-6).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span>
        <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pcs</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">pcs</span> <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">%</span> <span class="mi">12</span> <span class="o">==</span> <span class="n">ic</span><span class="p">)</span> <span class="k">for</span> <span class="n">ic</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
    <span class="p">]</span>


<div class="viewcode-block" id="compute_links">
<a class="viewcode-back" href="../../module_docs/atonal/base.html#atonal.base.compute_links">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">compute_links</span><span class="p">(</span>
    <span class="n">chord_table</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">id_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;id_&quot;</span><span class="p">,</span>
    <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;shared&quot;</span><span class="p">,</span>
    <span class="n">min_shared_pcs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">max_vl_distance</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">universe_pcs</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">12</span><span class="p">)),</span>
    <span class="n">reduce_transitive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">warning_threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">DEFAULT_WARNING_THRESHOLD</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute links between chords based on chosen criteria.</span>

<span class="sd">    Args:</span>
<span class="sd">        chord_table: list of dicts or DataFrame describing chords.</span>
<span class="sd">        id_col: name of chord ID column.</span>
<span class="sd">        kind: link definition - either a string or callable:</span>
<span class="sd">            String options:</span>
<span class="sd">            - &quot;shared&quot;: share &gt;= min_shared_pcs pitch classes</span>
<span class="sd">            - &quot;subset&quot;: subset relation in pitch-class space</span>
<span class="sd">            - &quot;voiceleading&quot;: voice-leading distance &lt;= max_vl_distance</span>
<span class="sd">            - &quot;codiatonic&quot;: both chords fit in same major scale</span>

<span class="sd">            Callable: custom function with signature:</span>
<span class="sd">                (i: int, j: int, voicings: List, pc_sets: List, **kwargs) -&gt; bool</span>
<span class="sd">                where i, j are chord indices, voicings is list of tuples,</span>
<span class="sd">                pc_sets is list of pitch-class sets, and kwargs includes</span>
<span class="sd">                min_shared_pcs and max_vl_distance</span>
<span class="sd">        min_shared_pcs: threshold for &#39;shared&#39; links</span>
<span class="sd">        max_vl_distance: max distance for &#39;voiceleading&#39; links</span>
<span class="sd">        warning_threshold: threshold for warning about large computations</span>

<span class="sd">    Returns:</span>
<span class="sd">        List of lists of chord IDs (parallel to input rows)</span>

<span class="sd">    &gt;&gt;&gt; rows = [</span>
<span class="sd">    ...     {&#39;id_&#39;: 0, &#39;voicing&#39;: (0, 4, 7), &#39;pitch_classes&#39;: [0, 4, 7]},</span>
<span class="sd">    ...     {&#39;id_&#39;: 1, &#39;voicing&#39;: (0, 5, 7), &#39;pitch_classes&#39;: [0, 5, 7]},</span>
<span class="sd">    ...     {&#39;id_&#39;: 2, &#39;voicing&#39;: (0, 4, 7, 11), &#39;pitch_classes&#39;: [0, 4, 7, 11]},</span>
<span class="sd">    ... ]</span>
<span class="sd">    &gt;&gt;&gt; links = compute_links(rows, kind=&quot;shared&quot;, min_shared_pcs=2)</span>
<span class="sd">    &gt;&gt;&gt; len(links[0]) &gt;= 1  # first chord should link to others</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Normalize to list of dicts</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">chord_table</span><span class="p">,</span> <span class="s2">&quot;to_dict&quot;</span><span class="p">):</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">chord_table</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="s2">&quot;records&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">chord_table</span><span class="p">)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
    <span class="n">_warn_if_large_computation</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="n">warning_threshold</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>

    <span class="c1"># Extract relevant data</span>
    <span class="n">voicings</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="s2">&quot;voicing&quot;</span><span class="p">])</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">]</span>
    <span class="n">ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="n">id_col</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">]</span>

    <span class="c1"># Precompute pitch-class sets for efficiency</span>
    <span class="n">pc_sets</span> <span class="o">=</span> <span class="p">[{</span><span class="n">p</span> <span class="o">%</span> <span class="mi">12</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">v</span><span class="p">}</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">voicings</span><span class="p">]</span>

    <span class="c1"># Build link function based on kind</span>
    <span class="n">link_func</span> <span class="o">=</span> <span class="n">_get_link_function</span><span class="p">(</span>
        <span class="n">kind</span><span class="p">,</span>
        <span class="n">pc_sets</span><span class="o">=</span><span class="n">pc_sets</span><span class="p">,</span>
        <span class="n">min_shared_pcs</span><span class="o">=</span><span class="n">min_shared_pcs</span><span class="p">,</span>
        <span class="n">max_vl_distance</span><span class="o">=</span><span class="n">max_vl_distance</span><span class="p">,</span>
        <span class="n">universe_pcs</span><span class="o">=</span><span class="n">universe_pcs</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Compute links</span>
    <span class="n">adjacency_idx</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="ow">and</span> <span class="n">link_func</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">voicings</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="k">if</span> <span class="n">reduce_transitive</span><span class="p">:</span>
        <span class="n">adjacency_idx</span> <span class="o">=</span> <span class="n">transitive_reduction_links</span><span class="p">(</span><span class="n">adjacency_idx</span><span class="p">,</span> <span class="n">require_dag</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">[[</span><span class="n">ids</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">js</span><span class="p">]</span> <span class="k">for</span> <span class="n">js</span> <span class="ow">in</span> <span class="n">adjacency_idx</span><span class="p">]</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_get_link_function</span><span class="p">(</span>
    <span class="n">kind</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">pc_sets</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="n">min_shared_pcs</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">max_vl_distance</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">universe_pcs</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]],</span> <span class="nb">bool</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a link function based on the specified kind.</span>

<span class="sd">    Args:</span>
<span class="sd">        kind: Either a string name (&quot;shared&quot;, &quot;subset&quot;, &quot;voiceleading&quot;, &quot;codiatonic&quot;)</span>
<span class="sd">              or a callable with signature (i: int, j: int, voicings, pc_sets, **kwargs) -&gt; bool</span>
<span class="sd">        pc_sets: Precomputed pitch-class sets for efficiency</span>
<span class="sd">        min_shared_pcs: Threshold for &#39;shared&#39; links</span>
<span class="sd">        max_vl_distance: Max distance for &#39;voiceleading&#39; links</span>

<span class="sd">    Returns:</span>
<span class="sd">        A link function with signature (i: int, j: int, voicings: List[Tuple]) -&gt; bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If it&#39;s already a callable, wrap it to provide pc_sets</span>
    <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">kind</span><span class="p">):</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">link_func</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">voicings</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">kind</span><span class="p">(</span>
                <span class="n">i</span><span class="p">,</span>
                <span class="n">j</span><span class="p">,</span>
                <span class="n">voicings</span><span class="p">,</span>
                <span class="n">pc_sets</span><span class="p">,</span>
                <span class="n">min_shared_pcs</span><span class="o">=</span><span class="n">min_shared_pcs</span><span class="p">,</span>
                <span class="n">max_vl_distance</span><span class="o">=</span><span class="n">max_vl_distance</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">link_func</span>

    <span class="c1"># Otherwise, look up by name</span>
    <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;shared&quot;</span><span class="p">:</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">link_func</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">voicings</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">pc_sets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">pc_sets</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="n">min_shared_pcs</span>

    <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;subset&quot;</span><span class="p">:</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">link_func</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">voicings</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pc_sets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">pc_sets</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

    <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;voiceleading&quot;</span><span class="p">:</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">link_func</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">voicings</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">voice_leading_distance</span><span class="p">(</span><span class="n">voicings</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">voicings</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">max_vl_distance</span>

    <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;codiatonic&quot;</span><span class="p">:</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">link_func</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">voicings</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">is_codiatonic</span><span class="p">(</span><span class="n">voicings</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">voicings</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

    <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;subset_kh&quot;</span><span class="p">:</span>
        <span class="c1"># Kh restriction: only include subset edges where both endpoints&#39;</span>
        <span class="c1"># complements are present in the node set.</span>
        <span class="n">universe</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">({</span><span class="n">p</span> <span class="o">%</span> <span class="mi">12</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">universe_pcs</span><span class="p">})</span>
        <span class="n">pc_frozens</span> <span class="o">=</span> <span class="p">[</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">pc_sets</span><span class="p">]</span>
        <span class="n">pc_index</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">FrozenSet</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pc_frozens</span><span class="p">)}</span>
        <span class="n">has_complement</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">universe</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">pc_frozens</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="ow">in</span> <span class="n">pc_index</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pc_frozens</span><span class="p">))</span>
        <span class="p">]</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">link_func</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">voicings</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">has_complement</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">has_complement</span><span class="p">[</span><span class="n">j</span><span class="p">]):</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="n">pc_sets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">pc_sets</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Unknown link kind: </span><span class="si">{</span><span class="n">kind</span><span class="si">}</span><span class="s2">. &quot;</span>
            <span class="s2">&quot;Must be &#39;shared&#39;, &#39;subset&#39;, &#39;subset_kh&#39;, &#39;voiceleading&#39;, &#39;codiatonic&#39;, or a custom callable.&quot;</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">link_func</span>


<span class="c1"># if __name__ == &quot;__main__&quot;:</span>
<span class="c1">#     import doctest</span>

<span class="c1">#     doctest.testmod()</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright NO COPYRIGHT.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>